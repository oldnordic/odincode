//! Pattern Matcher for Vulnerability Detection
//!
//! This module implements the core pattern matching logic for detecting
//! vulnerabilities in code using regex patterns and context validation.

use anyhow::Result;
use std::collections::HashMap;
use uuid::Uuid;

use crate::vulnerability_scanner::{
    config::VulnerabilityScannerConfig, DetectionMethod, VulnerabilityFinding,
};
use odincode_core::CodeFile;

use super::context_validator::ContextValidator;
use super::types::RegexVulnerabilityPattern;

/// Pattern matcher for executing pattern detection
pub struct PatternMatcher {
    /// Configuration for pattern matching
    config: VulnerabilityScannerConfig,
}

impl PatternMatcher {
    /// Create a new pattern matcher
    pub fn new(config: VulnerabilityScannerConfig) -> Self {
        Self { config }
    }

    /// Detect vulnerabilities using pattern matching
    pub fn detect_patterns(
        &self,
        file: &CodeFile,
        patterns: &[&RegexVulnerabilityPattern],
        context_validator: &ContextValidator,
    ) -> Result<Vec<VulnerabilityFinding>> {
        let mut findings = Vec::new();
        let lines: Vec<&str> = file.content.lines().collect();
        let mut context_lines: Vec<String> = Vec::new();

        for (line_num, line) in lines.iter().enumerate() {
            // Maintain context for multi-line analysis
            context_lines.push(line.to_string());
            if context_lines.len() > 5 {
                context_lines.remove(0);
            }

            let context = context_lines.join("\n");

            for pattern in patterns {
                if pattern.regex.is_match(line) {
                    // Check if pattern meets confidence threshold
                    if pattern.meets_confidence_threshold(self.config.confidence_threshold) {
                        // Check context requirements
                        if context_validator.validate_context(&context, pattern) {
                            if let Some(mat) = pattern.regex.find(line) {
                                let finding =
                                    self.create_finding(file, pattern, line_num, line, mat);
                                findings.push(finding);
                            }
                        }
                    }
                }
            }
        }

        Ok(findings)
    }

    /// Create a vulnerability finding from a pattern match
    fn create_finding(
        &self,
        file: &CodeFile,
        pattern: &RegexVulnerabilityPattern,
        line_num: usize,
        line: &str,
        mat: regex::Match,
    ) -> VulnerabilityFinding {
        VulnerabilityFinding {
            id: Uuid::new_v4(),
            file_path: file.path.clone(),
            line_number: line_num,
            column_number: mat.start(),
            severity: pattern.severity.clone(),
            category: pattern.category.clone(),
            title: pattern.name.clone(),
            description: pattern.description.clone(),
            code_snippet: line.to_string(),
            suggested_fix: pattern.suggested_fix.clone(),
            confidence: pattern.confidence,
            detection_method: DetectionMethod::PatternBased,
            cwe_id: pattern.cwe_id.clone(),
            metadata: {
                let mut meta = HashMap::new();
                meta.insert("pattern_name".to_string(), pattern.name.clone());
                meta.insert("match_start".to_string(), mat.start().to_string());
                meta.insert("match_end".to_string(), mat.end().to_string());
                meta
            },
        }
    }

    /// Detect patterns with detailed match information
    pub fn detect_patterns_with_details(
        &self,
        file: &CodeFile,
        patterns: &[&RegexVulnerabilityPattern],
        context_validator: &ContextValidator,
    ) -> Result<Vec<PatternMatch>> {
        let mut matches = Vec::new();
        let lines: Vec<&str> = file.content.lines().collect();
        let mut context_lines: Vec<String> = Vec::new();

        for (line_num, line) in lines.iter().enumerate() {
            // Maintain context for multi-line analysis
            context_lines.push(line.to_string());
            if context_lines.len() > 5 {
                context_lines.remove(0);
            }

            let context = context_lines.join("\n");

            for pattern in patterns {
                if pattern.regex.is_match(line) {
                    // Check if pattern meets confidence threshold
                    if pattern.meets_confidence_threshold(self.config.confidence_threshold) {
                        // Check context requirements
                        let context_valid = context_validator.validate_context(&context, pattern);

                        if let Some(mat) = pattern.regex.find(line) {
                            let pattern_match = PatternMatch {
                                pattern_name: pattern.name.clone(),
                                line_number: line_num,
                                column_start: mat.start(),
                                column_end: mat.end(),
                                matched_text: mat.as_str().to_string(),
                                line_content: line.to_string(),
                                context: context.clone(),
                                confidence: pattern.confidence,
                                context_valid,
                                severity: pattern.severity.clone(),
                                category: pattern.category.clone(),
                            };
                            matches.push(pattern_match);
                        }
                    }
                }
            }
        }

        Ok(matches)
    }

    /// Get patterns that match a specific line of code
    pub fn get_patterns_matching_line<'a>(
        &self,
        line: &str,
        patterns: &[&'a RegexVulnerabilityPattern],
    ) -> Vec<&'a RegexVulnerabilityPattern> {
        patterns
            .iter()
            .filter(|pattern| pattern.regex.is_match(line))
            .copied()
            .collect()
    }

    /// Get all matches for a specific pattern in a file
    pub fn get_all_matches_for_pattern(
        &self,
        file: &CodeFile,
        pattern: &RegexVulnerabilityPattern,
        context_validator: &ContextValidator,
    ) -> Result<Vec<PatternMatch>> {
        let mut matches = Vec::new();
        let lines: Vec<&str> = file.content.lines().collect();
        let mut context_lines: Vec<String> = Vec::new();

        for (line_num, line) in lines.iter().enumerate() {
            // Maintain context for multi-line analysis
            context_lines.push(line.to_string());
            if context_lines.len() > 5 {
                context_lines.remove(0);
            }

            let context = context_lines.join("\n");

            if pattern.regex.is_match(line) {
                // Check if pattern meets confidence threshold
                if pattern.meets_confidence_threshold(self.config.confidence_threshold) {
                    // Check context requirements
                    let context_valid = context_validator.validate_context(&context, pattern);

                    if let Some(mat) = pattern.regex.find(line) {
                        let pattern_match = PatternMatch {
                            pattern_name: pattern.name.clone(),
                            line_number: line_num,
                            column_start: mat.start(),
                            column_end: mat.end(),
                            matched_text: mat.as_str().to_string(),
                            line_content: line.to_string(),
                            context: context.clone(),
                            confidence: pattern.confidence,
                            context_valid,
                            severity: pattern.severity.clone(),
                            category: pattern.category.clone(),
                        };
                        matches.push(pattern_match);
                    }
                }
            }
        }

        Ok(matches)
    }

    /// Get pattern matching statistics
    pub fn get_matching_statistics(&self, matches: &[PatternMatch]) -> PatternMatchingStatistics {
        let mut pattern_counts = HashMap::new();
        let mut severity_counts = HashMap::new();
        let mut category_counts = HashMap::new();
        let mut confidence_sum = 0.0;
        let mut valid_context_count = 0;

        for pattern_match in matches {
            *pattern_counts
                .entry(pattern_match.pattern_name.clone())
                .or_insert(0) += 1;
            *severity_counts
                .entry(pattern_match.severity.clone())
                .or_insert(0) += 1;
            *category_counts
                .entry(pattern_match.category.clone())
                .or_insert(0) += 1;
            confidence_sum += pattern_match.confidence;
            if pattern_match.context_valid {
                valid_context_count += 1;
            }
        }

        PatternMatchingStatistics {
            total_matches: matches.len(),
            pattern_counts,
            severity_counts,
            category_counts,
            average_confidence: if matches.is_empty() {
                0.0
            } else {
                confidence_sum / matches.len() as f64
            },
            valid_context_percentage: if matches.is_empty() {
                0.0
            } else {
                (valid_context_count as f64 / matches.len() as f64) * 100.0
            },
        }
    }
}

/// Detailed information about a pattern match
#[derive(Debug, Clone)]
pub struct PatternMatch {
    pub pattern_name: String,
    pub line_number: usize,
    pub column_start: usize,
    pub column_end: usize,
    pub matched_text: String,
    pub line_content: String,
    pub context: String,
    pub confidence: f64,
    pub context_valid: bool,
    pub severity: crate::vulnerability_scanner::VulnerabilitySeverity,
    pub category: crate::vulnerability_scanner::VulnerabilityCategory,
}

/// Statistics about pattern matching
#[derive(Debug, Clone)]
pub struct PatternMatchingStatistics {
    pub total_matches: usize,
    pub pattern_counts: HashMap<String, usize>,
    pub severity_counts: HashMap<crate::vulnerability_scanner::VulnerabilitySeverity, usize>,
    pub category_counts: HashMap<crate::vulnerability_scanner::VulnerabilityCategory, usize>,
    pub average_confidence: f64,
    pub valid_context_percentage: f64,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::vulnerability_scanner::{
        VulnerabilityCategory, VulnerabilityScannerConfig, VulnerabilitySeverity,
    };

    #[test]
    fn test_pattern_matcher_creation() {
        let config = VulnerabilityScannerConfig::default();
        let matcher = PatternMatcher::new(config);
        assert_eq!(matcher.config.confidence_threshold, 0.7);
    }

    #[test]
    fn test_get_patterns_matching_line() {
        let config = VulnerabilityScannerConfig::default();
        let matcher = PatternMatcher::new(config);

        let pattern = RegexVulnerabilityPattern::new(
            "test_pattern".to_string(),
            "Test pattern".to_string(),
            regex::Regex::new(r"unsafe").unwrap(),
            VulnerabilityCategory::MemorySafety,
            VulnerabilitySeverity::Medium,
            0.8,
            "Fix it".to_string(),
            None,
            ["rust"].iter().map(|s| s.to_string()).collect(),
            vec![],
        );

        let patterns = vec![&pattern];
        let matches = matcher.get_patterns_matching_line("unsafe { }", &patterns);
        assert_eq!(matches.len(), 1);

        let no_matches = matcher.get_patterns_matching_line("safe code", &patterns);
        assert_eq!(no_matches.len(), 0);
    }

    #[test]
    fn test_pattern_matching_statistics() {
        let matches = vec![
            PatternMatch {
                pattern_name: "pattern1".to_string(),
                line_number: 1,
                column_start: 0,
                column_end: 5,
                matched_text: "test".to_string(),
                line_content: "test code".to_string(),
                context: "test context".to_string(),
                confidence: 0.8,
                context_valid: true,
                severity: VulnerabilitySeverity::Medium,
                category: VulnerabilityCategory::Security,
            },
            PatternMatch {
                pattern_name: "pattern1".to_string(),
                line_number: 2,
                column_start: 0,
                column_end: 5,
                matched_text: "test".to_string(),
                line_content: "test code".to_string(),
                context: "test context".to_string(),
                confidence: 0.9,
                context_valid: false,
                severity: VulnerabilitySeverity::High,
                category: VulnerabilityCategory::Security,
            },
        ];

        let stats = PatternMatcher::new(VulnerabilityScannerConfig::default())
            .get_matching_statistics(&matches);

        assert_eq!(stats.total_matches, 2);
        assert_eq!(stats.pattern_counts.get("pattern1"), Some(&2));
        assert_eq!(stats.average_confidence, 0.85);
        assert_eq!(stats.valid_context_percentage, 50.0);
    }

    #[test]
    fn test_create_finding() {
        let config = VulnerabilityScannerConfig::default();
        let matcher = PatternMatcher::new(config);

        let file = CodeFile {
            id: Uuid::new_v4(),
            path: "/test.rs".to_string(),
            content: "unsafe { }".to_string(),
            language: "rust".to_string(),
            modified: chrono::Utc::now(),
        };

        let pattern = RegexVulnerabilityPattern::new(
            "test_pattern".to_string(),
            "Test pattern".to_string(),
            regex::Regex::new(r"unsafe").unwrap(),
            VulnerabilityCategory::MemorySafety,
            VulnerabilitySeverity::Medium,
            0.8,
            "Fix it".to_string(),
            None,
            ["rust"].iter().map(|s| s.to_string()).collect(),
            vec![],
        );

        let line = "unsafe { }";
        let mat = pattern.regex.find(line).unwrap();
        let finding = matcher.create_finding(&file, &pattern, 0, line, mat);

        assert_eq!(finding.file_path, "/test.rs");
        assert_eq!(finding.line_number, 0);
        assert_eq!(finding.title, "test_pattern");
        assert_eq!(finding.confidence, 0.8);
    }
}
