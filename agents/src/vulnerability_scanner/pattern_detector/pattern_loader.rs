//! Pattern Loader for Vulnerability Patterns
//!
//! This module handles loading, managing, and indexing vulnerability patterns
//! for different programming languages.

use anyhow::Result;
use regex::Regex;
use std::collections::HashMap;

use super::types::{ContextRequirement, RegexVulnerabilityPattern};
use crate::vulnerability_scanner::{VulnerabilityCategory, VulnerabilitySeverity};

/// Pattern loader for managing vulnerability patterns
pub struct PatternLoader {
    /// All loaded vulnerability patterns
    patterns: Vec<RegexVulnerabilityPattern>,
    /// Language-specific pattern index
    language_patterns: HashMap<String, Vec<usize>>, // language -> pattern indices
}

impl PatternLoader {
    /// Create a new pattern loader with default patterns
    pub fn new() -> Result<Self> {
        let patterns = Self::load_default_patterns()?;
        let language_patterns = Self::build_language_index(&patterns);

        Ok(Self {
            patterns,
            language_patterns,
        })
    }

    /// Load default vulnerability patterns
    fn load_default_patterns() -> Result<Vec<RegexVulnerabilityPattern>> {
        let mut patterns = Vec::new();

        // Rust-specific patterns
        patterns.push(RegexVulnerabilityPattern::new(
            "rust_unsafe_block".to_string(),
            "Use of unsafe block in Rust code".to_string(),
            Regex::new(r"\bunsafe\b\s*\{")?,
            VulnerabilityCategory::MemorySafety,
            VulnerabilitySeverity::Medium,
            0.8,
            "Consider using safe Rust alternatives or add proper safety documentation".to_string(),
            Some("CWE-787".to_string()),
            ["rust"].iter().map(|s| s.to_string()).collect(),
            vec![],
        ));

        patterns.push(RegexVulnerabilityPattern::new(
            "rust_raw_pointer_dereference".to_string(),
            "Raw pointer dereference in Rust code".to_string(),
            Regex::new(r"\*\s*(const|mut)\s*\w+")?,
            VulnerabilityCategory::MemorySafety,
            VulnerabilitySeverity::High,
            0.9,
            "Consider using references or smart pointers instead of raw pointers".to_string(),
            Some("CWE-787".to_string()),
            ["rust"].iter().map(|s| s.to_string()).collect(),
            vec![],
        ));

        patterns.push(RegexVulnerabilityPattern::new(
            "rust_static_mut".to_string(),
            "Use of static mutable variable in Rust".to_string(),
            Regex::new(r"static\s+mut\s+\w+")?,
            VulnerabilityCategory::Concurrency,
            VulnerabilitySeverity::High,
            0.85,
            "Consider using thread-safe alternatives like Mutex or atomic types".to_string(),
            Some("CWE-362".to_string()),
            ["rust"].iter().map(|s| s.to_string()).collect(),
            vec![],
        ));

        // Python-specific patterns
        patterns.push(RegexVulnerabilityPattern::new(
            "python_eval_usage".to_string(),
            "Use of eval() function in Python".to_string(),
            Regex::new(r"\beval\s*\(")?,
            VulnerabilityCategory::Security,
            VulnerabilitySeverity::Critical,
            0.95,
            "Use safer alternatives like ast.literal_eval() or implement proper input validation"
                .to_string(),
            Some("CWE-94".to_string()),
            ["python"].iter().map(|s| s.to_string()).collect(),
            vec![ContextRequirement::ExcludesKeywords {
                keywords: vec!["literal_eval".to_string()],
                case_sensitive: false,
            }],
        ));

        patterns.push(RegexVulnerabilityPattern::new(
            "python_exec_usage".to_string(),
            "Use of exec() function in Python".to_string(),
            Regex::new(r"\bexec\s*\(")?,
            VulnerabilityCategory::Security,
            VulnerabilitySeverity::Critical,
            0.95,
            "Use safer alternatives or implement proper input validation and sandboxing"
                .to_string(),
            Some("CWE-94".to_string()),
            ["python"].iter().map(|s| s.to_string()).collect(),
            vec![],
        ));

        patterns.push(RegexVulnerabilityPattern::new(
            "python_pickle_usage".to_string(),
            "Use of pickle module in Python".to_string(),
            Regex::new(r"\bpickle\.")?,
            VulnerabilityCategory::Security,
            VulnerabilitySeverity::High,
            0.8,
            "Consider using safer serialization formats like JSON or implement proper validation"
                .to_string(),
            Some("CWE-502".to_string()),
            ["python"].iter().map(|s| s.to_string()).collect(),
            vec![],
        ));

        patterns.push(RegexVulnerabilityPattern::new(
            "python_subprocess_shell".to_string(),
            "Subprocess call with shell=True in Python".to_string(),
            Regex::new(r"subprocess\.(?:call|run|Popen)\([^)]*,\s*shell\s*=\s*True")?,
            VulnerabilityCategory::Security,
            VulnerabilitySeverity::High,
            0.9,
            "Avoid shell=True or properly sanitize input arguments".to_string(),
            Some("CWE-78".to_string()),
            ["python"].iter().map(|s| s.to_string()).collect(),
            vec![],
        ));

        // JavaScript/TypeScript patterns
        patterns.push(RegexVulnerabilityPattern::new(
            "js_eval_usage".to_string(),
            "Use of eval() in JavaScript/TypeScript".to_string(),
            Regex::new(r"\beval\s*\(")?,
            VulnerabilityCategory::Security,
            VulnerabilitySeverity::Critical,
            0.95,
            "Use safer alternatives like JSON.parse() or Function constructor".to_string(),
            Some("CWE-94".to_string()),
            ["javascript", "typescript"]
                .iter()
                .map(|s| s.to_string())
                .collect(),
            vec![],
        ));

        patterns.push(RegexVulnerabilityPattern::new(
            "js_innerhtml_usage".to_string(),
            "Use of innerHTML which can lead to XSS".to_string(),
            Regex::new(r"\.innerHTML\s*=")?,
            VulnerabilityCategory::Security,
            VulnerabilitySeverity::High,
            0.8,
            "Use textContent or proper sanitization libraries".to_string(),
            Some("CWE-79".to_string()),
            ["javascript", "typescript"]
                .iter()
                .map(|s| s.to_string())
                .collect(),
            vec![],
        ));

        patterns.push(RegexVulnerabilityPattern::new(
            "js_document_write".to_string(),
            "Use of document.write() which can lead to XSS".to_string(),
            Regex::new(r"document\.write\s*\(")?,
            VulnerabilityCategory::Security,
            VulnerabilitySeverity::High,
            0.85,
            "Use DOM manipulation methods or proper templating".to_string(),
            Some("CWE-79".to_string()),
            ["javascript", "typescript"]
                .iter()
                .map(|s| s.to_string())
                .collect(),
            vec![],
        ));

        // SQL injection patterns (multi-language)
        patterns.push(RegexVulnerabilityPattern::new(
            "sql_string_concatenation".to_string(),
            "SQL query built with string concatenation".to_string(),
            Regex::new(r"(SELECT|INSERT|UPDATE|DELETE)\s+.*\+.*")?,
            VulnerabilityCategory::Security,
            VulnerabilitySeverity::Critical,
            0.75,
            "Use parameterized queries or prepared statements".to_string(),
            Some("CWE-89".to_string()),
            ["python", "javascript", "typescript", "go", "rust"]
                .iter()
                .map(|s| s.to_string())
                .collect(),
            vec![ContextRequirement::ExcludesKeywords {
                keywords: vec![
                    "prepare".to_string(),
                    "parameterized".to_string(),
                    "query_params".to_string(),
                ],
                case_sensitive: false,
            }],
        ));

        patterns.push(RegexVulnerabilityPattern::new(
            "sql_format_string".to_string(),
            "SQL query built with format string".to_string(),
            Regex::new(r"(SELECT|INSERT|UPDATE|DELETE)\s+.*%.*")?,
            VulnerabilityCategory::Security,
            VulnerabilitySeverity::Critical,
            0.8,
            "Use parameterized queries or prepared statements".to_string(),
            Some("CWE-89".to_string()),
            ["python", "javascript", "typescript", "go", "rust"]
                .iter()
                .map(|s| s.to_string())
                .collect(),
            vec![],
        ));

        // Buffer overflow patterns
        patterns.push(RegexVulnerabilityPattern::new(
            "c_unsafe_functions".to_string(),
            "Use of unsafe C functions prone to buffer overflow".to_string(),
            Regex::new(r"\b(strcpy|strcat|gets|sprintf|vsprintf)\s*\(")?,
            VulnerabilityCategory::MemorySafety,
            VulnerabilitySeverity::Critical,
            0.9,
            "Use safer alternatives like strncpy, strncat, fgets, snprintf".to_string(),
            Some("CWE-120".to_string()),
            ["c", "cpp", "rust"].iter().map(|s| s.to_string()).collect(),
            vec![],
        ));

        // Path traversal patterns
        patterns.push(RegexVulnerabilityPattern::new(
            "path_traversal_user_input".to_string(),
            "File operations with user input that could lead to path traversal".to_string(),
            Regex::new(r"(open|read|write|fopen|File)\s*\([^)]*(?:input|user|request|param)")?,
            VulnerabilityCategory::Security,
            VulnerabilitySeverity::High,
            0.7,
            "Validate and sanitize file paths, use path canonicalization".to_string(),
            Some("CWE-22".to_string()),
            [
                "python",
                "javascript",
                "typescript",
                "go",
                "rust",
                "c",
                "cpp",
            ]
            .iter()
            .map(|s| s.to_string())
            .collect(),
            vec![ContextRequirement::ExcludesKeywords {
                keywords: vec![
                    "abspath".to_string(),
                    "canonicalize".to_string(),
                    "normpath".to_string(),
                ],
                case_sensitive: false,
            }],
        ));

        // Hardcoded secrets patterns
        patterns.push(RegexVulnerabilityPattern::new(
            "hardcoded_password".to_string(),
            "Hardcoded password or secret in code".to_string(),
            Regex::new(r#"(?i)(password|secret|key|token)\s*=\s*["'][^"']{8,}["']"#)?,
            VulnerabilityCategory::Security,
            VulnerabilitySeverity::High,
            0.85,
            "Move secrets to environment variables or secure configuration files".to_string(),
            Some("CWE-259".to_string()),
            [
                "python",
                "javascript",
                "typescript",
                "go",
                "rust",
                "c",
                "cpp",
            ]
            .iter()
            .map(|s| s.to_string())
            .collect(),
            vec![],
        ));

        patterns.push(RegexVulnerabilityPattern::new(
            "hardcoded_api_key".to_string(),
            "Hardcoded API key in code".to_string(),
            Regex::new(
                r#"(?i)(api_key|apikey|access_key|accesskey)\s*=\s*["'][A-Za-z0-9+/]{16,}["']"#,
            )?,
            VulnerabilityCategory::Security,
            VulnerabilitySeverity::High,
            0.9,
            "Move API keys to environment variables or secure secret management".to_string(),
            Some("CWE-798".to_string()),
            [
                "python",
                "javascript",
                "typescript",
                "go",
                "rust",
                "c",
                "cpp",
            ]
            .iter()
            .map(|s| s.to_string())
            .collect(),
            vec![],
        ));

        // Command injection patterns
        patterns.push(RegexVulnerabilityPattern::new(
            "os_system_user_input".to_string(),
            "OS system command with user input".to_string(),
            Regex::new(r"os\.system\s*\([^)]*(?:input|user|request|param)")?,
            VulnerabilityCategory::Security,
            VulnerabilitySeverity::Critical,
            0.9,
            "Use subprocess with proper argument escaping or avoid shell commands".to_string(),
            Some("CWE-78".to_string()),
            ["python"].iter().map(|s| s.to_string()).collect(),
            vec![],
        ));

        // Integer overflow patterns
        patterns.push(RegexVulnerabilityPattern::new(
            "potential_integer_overflow".to_string(),
            "Potential integer overflow in arithmetic operations".to_string(),
            Regex::new(r"\w+\s*\+\s*\w+\s*\*\s*\w+")?,
            VulnerabilityCategory::MemorySafety,
            VulnerabilitySeverity::Medium,
            0.6,
            "Add bounds checking or use larger integer types".to_string(),
            Some("CWE-190".to_string()),
            ["c", "cpp", "rust", "go"]
                .iter()
                .map(|s| s.to_string())
                .collect(),
            vec![],
        ));

        Ok(patterns)
    }

    /// Build language-specific pattern index
    fn build_language_index(patterns: &[RegexVulnerabilityPattern]) -> HashMap<String, Vec<usize>> {
        let mut index = HashMap::new();

        for (idx, pattern) in patterns.iter().enumerate() {
            for language in &pattern.languages {
                index
                    .entry(language.clone())
                    .or_insert_with(Vec::new)
                    .push(idx);
            }
        }

        index
    }

    /// Get all patterns
    pub fn get_all_patterns(&self) -> Vec<&RegexVulnerabilityPattern> {
        self.patterns.iter().collect()
    }

    /// Get patterns for a specific language
    pub fn get_patterns_for_language(&self, language: &str) -> Vec<&RegexVulnerabilityPattern> {
        let language_lower = language.to_lowercase();
        if let Some(pattern_indices) = self.language_patterns.get(&language_lower) {
            pattern_indices
                .iter()
                .filter_map(|&idx| self.patterns.get(idx))
                .collect()
        } else {
            // If no language-specific patterns, return all patterns
            self.patterns.iter().collect()
        }
    }

    /// Get patterns by category
    pub fn get_patterns_by_category(
        &self,
        category: VulnerabilityCategory,
    ) -> Vec<&RegexVulnerabilityPattern> {
        self.patterns
            .iter()
            .filter(|p| p.category == category)
            .collect()
    }

    /// Get patterns by severity
    pub fn get_patterns_by_severity(
        &self,
        severity: VulnerabilitySeverity,
    ) -> Vec<&RegexVulnerabilityPattern> {
        self.patterns
            .iter()
            .filter(|p| p.severity == severity)
            .collect()
    }

    /// Add a new pattern
    pub fn add_pattern(&mut self, pattern: RegexVulnerabilityPattern) -> Result<()> {
        let pattern_index = self.patterns.len();
        self.patterns.push(pattern.clone());

        // Update language index
        for language in &pattern.languages {
            self.language_patterns
                .entry(language.clone())
                .or_insert_with(Vec::new)
                .push(pattern_index);
        }

        Ok(())
    }

    /// Remove a pattern by name
    pub fn remove_pattern(&mut self, pattern_name: &str) -> Result<()> {
        // Find pattern index
        if let Some(index) = self.patterns.iter().position(|p| p.name == pattern_name) {
            let pattern = self.patterns.remove(index);

            // Remove from language index
            for language in &pattern.languages {
                if let Some(patterns) = self.language_patterns.get_mut(language) {
                    patterns.retain(|&idx| idx != index);
                    // Adjust indices after removal
                    for idx in patterns.iter_mut() {
                        if *idx > index {
                            *idx -= 1;
                        }
                    }
                }
            }
        }

        Ok(())
    }

    /// Get pattern statistics
    pub fn get_statistics(&self) -> PatternStatistics {
        let mut category_counts = std::collections::HashMap::new();
        let mut severity_counts = std::collections::HashMap::new();
        let mut language_counts = std::collections::HashMap::new();

        for pattern in &self.patterns {
            *category_counts.entry(pattern.category.clone()).or_insert(0) += 1;
            *severity_counts.entry(pattern.severity.clone()).or_insert(0) += 1;
            for language in &pattern.languages {
                *language_counts.entry(language.clone()).or_insert(0) += 1;
            }
        }

        PatternStatistics {
            total_patterns: self.patterns.len(),
            category_counts,
            severity_counts,
            language_counts,
        }
    }

    /// Search patterns by name or description
    pub fn search_patterns(&self, query: &str) -> Vec<&RegexVulnerabilityPattern> {
        let query_lower = query.to_lowercase();
        self.patterns
            .iter()
            .filter(|p| {
                p.name.to_lowercase().contains(&query_lower)
                    || p.description.to_lowercase().contains(&query_lower)
            })
            .collect()
    }
}

/// Statistics about loaded patterns
pub struct PatternStatistics {
    pub total_patterns: usize,
    pub category_counts: std::collections::HashMap<VulnerabilityCategory, usize>,
    pub severity_counts: std::collections::HashMap<VulnerabilitySeverity, usize>,
    pub language_counts: std::collections::HashMap<String, usize>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pattern_loader_creation() {
        let loader = PatternLoader::new().unwrap();
        assert!(!loader.get_all_patterns().is_empty());
    }

    #[test]
    fn test_get_patterns_for_language() {
        let loader = PatternLoader::new().unwrap();
        let rust_patterns = loader.get_patterns_for_language("rust");
        assert!(!rust_patterns.is_empty());

        let rust_pattern_names: Vec<String> =
            rust_patterns.iter().map(|p| p.name.clone()).collect();
        assert!(rust_pattern_names.contains(&"rust_unsafe_block".to_string()));
    }

    #[test]
    fn test_get_patterns_by_category() {
        let loader = PatternLoader::new().unwrap();
        let security_patterns = loader.get_patterns_by_category(VulnerabilityCategory::Security);
        assert!(!security_patterns.is_empty());
    }

    #[test]
    fn test_add_and_remove_pattern() {
        let mut loader = PatternLoader::new().unwrap();
        let initial_count = loader.get_all_patterns().len();

        let custom_pattern = RegexVulnerabilityPattern::new(
            "test_pattern".to_string(),
            "Test pattern".to_string(),
            Regex::new(r"test").unwrap(),
            VulnerabilityCategory::CodeQuality,
            VulnerabilitySeverity::Low,
            0.5,
            "Fix it".to_string(),
            None,
            ["test"].iter().map(|s| s.to_string()).collect(),
            vec![],
        );

        loader.add_pattern(custom_pattern).unwrap();
        assert_eq!(loader.get_all_patterns().len(), initial_count + 1);

        loader.remove_pattern("test_pattern").unwrap();
        assert_eq!(loader.get_all_patterns().len(), initial_count);
    }

    #[test]
    fn test_search_patterns() {
        let loader = PatternLoader::new().unwrap();
        let results = loader.search_patterns("unsafe");
        assert!(!results.is_empty());

        let results = loader.search_patterns("nonexistent");
        assert!(results.is_empty());
    }

    #[test]
    fn test_pattern_statistics() {
        let loader = PatternLoader::new().unwrap();
        let stats = loader.get_statistics();

        assert!(stats.total_patterns > 0);
        assert!(!stats.category_counts.is_empty());
        assert!(!stats.severity_counts.is_empty());
        assert!(!stats.language_counts.is_empty());
    }
}
