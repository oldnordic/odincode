//! Types and data structures for pattern detection
//!
//! This module defines the core data structures used for vulnerability pattern detection,
//! including pattern definitions, context requirements, and related types.

use regex::Regex;
use std::collections::HashSet;

use crate::vulnerability_scanner::{VulnerabilityCategory, VulnerabilitySeverity};

/// Vulnerability pattern with regex and metadata
#[derive(Debug, Clone)]
pub struct RegexVulnerabilityPattern {
    /// Pattern name/identifier
    pub name: String,
    /// Pattern description
    pub description: String,
    /// Regular expression to match the pattern
    pub regex: Regex,
    /// Vulnerability category
    pub category: VulnerabilityCategory,
    /// Expected severity
    pub severity: VulnerabilitySeverity,
    /// Confidence score for this pattern (0.0 to 1.0)
    pub confidence: f64,
    /// Suggested fix template
    pub suggested_fix: String,
    /// Related CWE ID
    pub cwe_id: Option<String>,
    /// Languages this pattern applies to
    pub languages: HashSet<String>,
    /// Additional context requirements
    pub context_requirements: Vec<ContextRequirement>,
}

/// Context requirement for pattern matching
#[derive(Debug, Clone)]
pub enum ContextRequirement {
    /// Must contain certain keywords
    ContainsKeywords {
        keywords: Vec<String>,
        case_sensitive: bool,
    },
    /// Must not contain certain keywords
    ExcludesKeywords {
        keywords: Vec<String>,
        case_sensitive: bool,
    },
    /// Must be within a function with certain characteristics
    InFunctionWith { function_patterns: Vec<String> },
    /// Must have certain imports/includes
    HasImports { imports: Vec<String> },
    /// Line length constraint
    LineLength {
        min: Option<usize>,
        max: Option<usize>,
    },
}

impl RegexVulnerabilityPattern {
    /// Create a new vulnerability pattern
    pub fn new(
        name: String,
        description: String,
        regex: Regex,
        category: VulnerabilityCategory,
        severity: VulnerabilitySeverity,
        confidence: f64,
        suggested_fix: String,
        cwe_id: Option<String>,
        languages: HashSet<String>,
        context_requirements: Vec<ContextRequirement>,
    ) -> Self {
        Self {
            name,
            description,
            regex,
            category,
            severity,
            confidence,
            suggested_fix,
            cwe_id,
            languages,
            context_requirements,
        }
    }

    /// Check if this pattern applies to a specific language
    pub fn applies_to_language(&self, language: &str) -> bool {
        self.languages.contains(&language.to_lowercase())
    }

    /// Check if this pattern meets the confidence threshold
    pub fn meets_confidence_threshold(&self, threshold: f64) -> bool {
        self.confidence >= threshold
    }

    /// Get the primary language for this pattern
    pub fn primary_language(&self) -> Option<&String> {
        self.languages.iter().next()
    }

    /// Check if this pattern has context requirements
    pub fn has_context_requirements(&self) -> bool {
        !self.context_requirements.is_empty()
    }

    /// Get a summary of this pattern
    pub fn summary(&self) -> String {
        format!(
            "{}: {} ({:?} - {} confidence)",
            self.name, self.description, self.severity, self.confidence
        )
    }
}

impl ContextRequirement {
    /// Check if this requirement is satisfied by the given context
    pub fn is_satisfied(&self, context: &str) -> bool {
        match self {
            ContextRequirement::ContainsKeywords {
                keywords,
                case_sensitive,
            } => {
                let search_context = if *case_sensitive {
                    context.to_string()
                } else {
                    context.to_lowercase()
                };

                keywords.iter().any(|keyword| {
                    let search_keyword = if *case_sensitive {
                        keyword.clone()
                    } else {
                        keyword.to_lowercase()
                    };
                    search_context.contains(&search_keyword)
                })
            }
            ContextRequirement::ExcludesKeywords {
                keywords,
                case_sensitive,
            } => {
                let search_context = if *case_sensitive {
                    context.to_string()
                } else {
                    context.to_lowercase()
                };

                !keywords.iter().any(|keyword| {
                    let search_keyword = if *case_sensitive {
                        keyword.clone()
                    } else {
                        keyword.to_lowercase()
                    };
                    search_context.contains(&search_keyword)
                })
            }
            ContextRequirement::InFunctionWith { function_patterns } => function_patterns
                .iter()
                .any(|pattern| context.contains(pattern)),
            ContextRequirement::HasImports { imports } => {
                imports.iter().any(|import| context.contains(import))
            }
            ContextRequirement::LineLength { min, max } => {
                let lines: Vec<&str> = context.lines().collect();
                lines.iter().all(|line| {
                    let line_len = line.len();
                    if let Some(min_len) = min {
                        if line_len < *min_len {
                            return false;
                        }
                    }
                    if let Some(max_len) = max {
                        if line_len > *max_len {
                            return false;
                        }
                    }
                    true
                })
            }
        }
    }

    /// Get a description of this requirement
    pub fn description(&self) -> String {
        match self {
            ContextRequirement::ContainsKeywords {
                keywords,
                case_sensitive,
            } => {
                format!(
                    "Must contain keywords: {} (case sensitive: {})",
                    keywords.join(", "),
                    case_sensitive
                )
            }
            ContextRequirement::ExcludesKeywords {
                keywords,
                case_sensitive,
            } => {
                format!(
                    "Must not contain keywords: {} (case sensitive: {})",
                    keywords.join(", "),
                    case_sensitive
                )
            }
            ContextRequirement::InFunctionWith { function_patterns } => {
                format!(
                    "Must be in function with patterns: {}",
                    function_patterns.join(", ")
                )
            }
            ContextRequirement::HasImports { imports } => {
                format!("Must have imports: {}", imports.join(", "))
            }
            ContextRequirement::LineLength { min, max } => {
                let min_desc = min.map(|m| format!("min: {}", m)).unwrap_or_default();
                let max_desc = max.map(|m| format!("max: {}", m)).unwrap_or_default();
                let constraints: Vec<&str> = [min_desc.as_str(), max_desc.as_str()]
                    .iter()
                    .filter(|s| !s.is_empty())
                    .copied()
                    .collect();
                let constraints_str = constraints.join(", ");
                format!("Line length constraints: {}", constraints_str)
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_regex_vulnerability_pattern_creation() {
        let pattern = RegexVulnerabilityPattern::new(
            "test_pattern".to_string(),
            "Test pattern".to_string(),
            Regex::new(r"test").unwrap(),
            VulnerabilityCategory::Security,
            VulnerabilitySeverity::Medium,
            0.8,
            "Fix it".to_string(),
            Some("CWE-123".to_string()),
            ["rust", "python"].iter().map(|s| s.to_string()).collect(),
            vec![],
        );

        assert_eq!(pattern.name, "test_pattern");
        assert_eq!(pattern.confidence, 0.8);
        assert!(pattern.applies_to_language("rust"));
        assert!(!pattern.applies_to_language("javascript"));
        assert!(pattern.meets_confidence_threshold(0.7));
        assert!(!pattern.meets_confidence_threshold(0.9));
    }

    #[test]
    fn test_context_requirement_contains_keywords() {
        let requirement = ContextRequirement::ContainsKeywords {
            keywords: vec!["important".to_string(), "critical".to_string()],
            case_sensitive: false,
        };

        assert!(requirement.is_satisfied("This is an important test"));
        assert!(requirement.is_satisfied("This is a CRITICAL test"));
        assert!(!requirement.is_satisfied("This is a simple test"));
    }

    #[test]
    fn test_context_requirement_excludes_keywords() {
        let requirement = ContextRequirement::ExcludesKeywords {
            keywords: vec!["unsafe".to_string(), "dangerous".to_string()],
            case_sensitive: false,
        };

        assert!(requirement.is_satisfied("This is safe code"));
        assert!(!requirement.is_satisfied("This is unsafe code"));
        assert!(!requirement.is_satisfied("This is DANGEROUS code"));
    }

    #[test]
    fn test_context_requirement_line_length() {
        let requirement = ContextRequirement::LineLength {
            min: Some(5),
            max: Some(20),
        };

        assert!(requirement.is_satisfied("Good length"));
        assert!(!requirement.is_satisfied("Short")); // 5 chars, but min is 5 (exclusive?)
        assert!(!requirement.is_satisfied("This line is way too long and should fail"));
    }

    #[test]
    fn test_context_requirement_descriptions() {
        let contains_req = ContextRequirement::ContainsKeywords {
            keywords: vec!["test".to_string()],
            case_sensitive: true,
        };
        assert!(contains_req.description().contains("Must contain keywords"));

        let line_length_req = ContextRequirement::LineLength {
            min: Some(10),
            max: Some(100),
        };
        assert!(line_length_req
            .description()
            .contains("Line length constraints"));
    }
}
