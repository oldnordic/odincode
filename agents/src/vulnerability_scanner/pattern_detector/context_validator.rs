//! Context Validator for Pattern Requirements
//!
//! This module handles validation of context requirements for vulnerability patterns,
//! ensuring that patterns are only matched when appropriate context conditions are met.

use super::types::{ContextRequirement, RegexVulnerabilityPattern};

/// Context validator for checking pattern requirements
pub struct ContextValidator {
    /// Cache for validation results to improve performance
    validation_cache: std::collections::HashMap<String, bool>,
}

impl ContextValidator {
    /// Create a new context validator
    pub fn new() -> Self {
        Self {
            validation_cache: std::collections::HashMap::new(),
        }
    }

    /// Validate context requirements for a pattern
    pub fn validate_context(&self, context: &str, pattern: &RegexVulnerabilityPattern) -> bool {
        // If no context requirements, pattern is valid
        if pattern.context_requirements.is_empty() {
            return true;
        }

        // Check each requirement
        for requirement in &pattern.context_requirements {
            if !self.validate_requirement(context, requirement) {
                return false;
            }
        }

        true
    }

    /// Validate a single context requirement
    fn validate_requirement(&self, context: &str, requirement: &ContextRequirement) -> bool {
        // Create a cache key for this validation
        let cache_key = self.create_cache_key(context, requirement);

        // Check cache first
        if let Some(&result) = self.validation_cache.get(&cache_key) {
            return result;
        }

        // Perform validation
        let result = requirement.is_satisfied(context);

        // Cache the result (in a real implementation, we'd need to handle cache invalidation)
        // For now, we'll skip caching to avoid memory issues with large contexts
        // self.validation_cache.insert(cache_key, result);

        result
    }

    /// Create a cache key for validation results
    fn create_cache_key(&self, context: &str, requirement: &ContextRequirement) -> String {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};

        let mut hasher = DefaultHasher::new();
        context.hash(&mut hasher);
        std::mem::discriminant(requirement).hash(&mut hasher);

        // Add requirement-specific data to hash
        match requirement {
            ContextRequirement::ContainsKeywords {
                keywords,
                case_sensitive,
            } => {
                keywords.hash(&mut hasher);
                case_sensitive.hash(&mut hasher);
            }
            ContextRequirement::ExcludesKeywords {
                keywords,
                case_sensitive,
            } => {
                keywords.hash(&mut hasher);
                case_sensitive.hash(&mut hasher);
            }
            ContextRequirement::InFunctionWith { function_patterns } => {
                function_patterns.hash(&mut hasher);
            }
            ContextRequirement::HasImports { imports } => {
                imports.hash(&mut hasher);
            }
            ContextRequirement::LineLength { min, max } => {
                min.hash(&mut hasher);
                max.hash(&mut hasher);
            }
        }

        format!("ctx_val_{}", hasher.finish())
    }

    /// Validate context with detailed results
    pub fn validate_context_with_details(
        &self,
        context: &str,
        pattern: &RegexVulnerabilityPattern,
    ) -> ContextValidationResult {
        let mut requirement_results = Vec::new();
        let mut all_valid = true;

        for requirement in &pattern.context_requirements {
            let is_valid = self.validate_requirement(context, requirement);
            requirement_results.push(ContextRequirementResult {
                requirement: requirement.clone(),
                is_valid,
                description: requirement.description(),
            });

            if !is_valid {
                all_valid = false;
            }
        }

        ContextValidationResult {
            is_valid: all_valid,
            requirement_results,
            context_preview: self.get_context_preview(context),
        }
    }

    /// Get a preview of the context for debugging
    fn get_context_preview(&self, context: &str) -> String {
        let lines: Vec<&str> = context.lines().collect();
        let preview_lines: Vec<&str> = lines.iter().take(3).copied().collect();
        preview_lines.join("\n")
    }

    /// Check if context contains specific keywords
    pub fn contains_keywords(
        &self,
        context: &str,
        keywords: &[String],
        case_sensitive: bool,
    ) -> bool {
        let search_context = if case_sensitive {
            context.to_string()
        } else {
            context.to_lowercase()
        };

        keywords.iter().any(|keyword| {
            let search_keyword = if case_sensitive {
                keyword.clone()
            } else {
                keyword.to_lowercase()
            };
            search_context.contains(&search_keyword)
        })
    }

    /// Check if context excludes specific keywords
    pub fn excludes_keywords(
        &self,
        context: &str,
        keywords: &[String],
        case_sensitive: bool,
    ) -> bool {
        !self.contains_keywords(context, keywords, case_sensitive)
    }

    /// Check if context is within a function with specific patterns
    pub fn in_function_with_patterns(&self, context: &str, function_patterns: &[String]) -> bool {
        function_patterns
            .iter()
            .any(|pattern| context.contains(pattern))
    }

    /// Check if context has specific imports
    pub fn has_imports(&self, context: &str, imports: &[String]) -> bool {
        imports.iter().any(|import| context.contains(import))
    }

    /// Check if context meets line length constraints
    pub fn meets_line_length_constraints(
        &self,
        context: &str,
        min: Option<usize>,
        max: Option<usize>,
    ) -> bool {
        let lines: Vec<&str> = context.lines().collect();
        lines.iter().all(|line| {
            let line_len = line.len();
            if let Some(min_len) = min {
                if line_len < min_len {
                    return false;
                }
            }
            if let Some(max_len) = max {
                if line_len > max_len {
                    return false;
                }
            }
            true
        })
    }

    /// Get validation statistics
    pub fn get_validation_statistics(&self) -> ContextValidationStatistics {
        ContextValidationStatistics {
            cache_size: self.validation_cache.len(),
            cache_hit_rate: 0.0, // Would need to track hits/misses
        }
    }

    /// Clear the validation cache
    pub fn clear_cache(&mut self) {
        self.validation_cache.clear();
    }
}

/// Result of context validation with detailed information
#[derive(Debug, Clone)]
pub struct ContextValidationResult {
    pub is_valid: bool,
    pub requirement_results: Vec<ContextRequirementResult>,
    pub context_preview: String,
}

/// Result of validating a single context requirement
#[derive(Debug, Clone)]
pub struct ContextRequirementResult {
    pub requirement: ContextRequirement,
    pub is_valid: bool,
    pub description: String,
}

/// Statistics about context validation
#[derive(Debug, Clone)]
pub struct ContextValidationStatistics {
    pub cache_size: usize,
    pub cache_hit_rate: f64,
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::vulnerability_scanner::{VulnerabilityCategory, VulnerabilitySeverity};

    #[test]
    fn test_context_validator_creation() {
        let validator = ContextValidator::new();
        assert_eq!(validator.validation_cache.len(), 0);
    }

    #[test]
    fn test_validate_context_no_requirements() {
        let validator = ContextValidator::new();
        let pattern = RegexVulnerabilityPattern::new(
            "test_pattern".to_string(),
            "Test pattern".to_string(),
            regex::Regex::new(r"test").unwrap(),
            VulnerabilityCategory::Security,
            VulnerabilitySeverity::Medium,
            0.8,
            "Fix it".to_string(),
            None,
            ["rust"].iter().map(|s| s.to_string()).collect(),
            vec![],
        );

        assert!(validator.validate_context("test context", &pattern));
    }

    #[test]
    fn test_validate_context_with_requirements() {
        let validator = ContextValidator::new();
        let pattern = RegexVulnerabilityPattern::new(
            "test_pattern".to_string(),
            "Test pattern".to_string(),
            regex::Regex::new(r"test").unwrap(),
            VulnerabilityCategory::Security,
            VulnerabilitySeverity::Medium,
            0.8,
            "Fix it".to_string(),
            None,
            ["rust"].iter().map(|s| s.to_string()).collect(),
            vec![ContextRequirement::ContainsKeywords {
                keywords: vec!["important".to_string()],
                case_sensitive: false,
            }],
        );

        // Should pass - contains keyword
        assert!(validator.validate_context("This is an important test", &pattern));

        // Should fail - doesn't contain keyword
        assert!(!validator.validate_context("This is a simple test", &pattern));
    }

    #[test]
    fn test_validate_context_with_details() {
        let validator = ContextValidator::new();
        let pattern = RegexVulnerabilityPattern::new(
            "test_pattern".to_string(),
            "Test pattern".to_string(),
            regex::Regex::new(r"test").unwrap(),
            VulnerabilityCategory::Security,
            VulnerabilitySeverity::Medium,
            0.8,
            "Fix it".to_string(),
            None,
            ["rust"].iter().map(|s| s.to_string()).collect(),
            vec![ContextRequirement::ContainsKeywords {
                keywords: vec!["important".to_string()],
                case_sensitive: false,
            }],
        );

        let result = validator.validate_context_with_details("This is an important test", &pattern);
        assert!(result.is_valid);
        assert_eq!(result.requirement_results.len(), 1);
        assert!(result.requirement_results[0].is_valid);
    }

    #[test]
    fn test_contains_keywords() {
        let validator = ContextValidator::new();

        assert!(validator.contains_keywords(
            "This is important",
            &["important".to_string()],
            false
        ));
        assert!(validator.contains_keywords(
            "This is IMPORTANT",
            &["important".to_string()],
            false
        ));
        assert!(!validator.contains_keywords("This is simple", &["important".to_string()], false));

        assert!(validator.contains_keywords("This is Important", &["Important".to_string()], true));
        assert!(!validator.contains_keywords(
            "This is important",
            &["Important".to_string()],
            true
        ));
    }

    #[test]
    fn test_excludes_keywords() {
        let validator = ContextValidator::new();

        assert!(validator.excludes_keywords("This is safe", &["unsafe".to_string()], false));
        assert!(!validator.excludes_keywords("This is unsafe", &["unsafe".to_string()], false));
    }

    #[test]
    fn test_line_length_constraints() {
        let validator = ContextValidator::new();

        assert!(validator.meets_line_length_constraints("Good length", Some(5), Some(20)));
        assert!(!validator.meets_line_length_constraints("Short", Some(10), Some(20)));
        assert!(!validator.meets_line_length_constraints(
            "This line is way too long",
            Some(5),
            Some(20)
        ));
    }

    #[test]
    fn test_cache_operations() {
        let mut validator = ContextValidator::new();
        assert_eq!(validator.get_validation_statistics().cache_size, 0);

        validator.clear_cache();
        assert_eq!(validator.get_validation_statistics().cache_size, 0);
    }

    #[test]
    fn test_multiple_requirements() {
        let validator = ContextValidator::new();
        let pattern = RegexVulnerabilityPattern::new(
            "test_pattern".to_string(),
            "Test pattern".to_string(),
            regex::Regex::new(r"test").unwrap(),
            VulnerabilityCategory::Security,
            VulnerabilitySeverity::Medium,
            0.8,
            "Fix it".to_string(),
            None,
            ["rust"].iter().map(|s| s.to_string()).collect(),
            vec![
                ContextRequirement::ContainsKeywords {
                    keywords: vec!["important".to_string()],
                    case_sensitive: false,
                },
                ContextRequirement::ExcludesKeywords {
                    keywords: vec!["unsafe".to_string()],
                    case_sensitive: false,
                },
            ],
        );

        // Should pass - contains "important" and excludes "unsafe"
        assert!(validator.validate_context("This is an important safe test", &pattern));

        // Should fail - contains "important" but also contains "unsafe"
        assert!(!validator.validate_context("This is an important unsafe test", &pattern));

        // Should fail - excludes "unsafe" but doesn't contain "important"
        assert!(!validator.validate_context("This is a safe test", &pattern));
    }
}
