//! Pattern Detector Module
//!
//! This module implements pattern-based vulnerability detection using
//! predefined rules and signatures for known vulnerability patterns.
//!
//! The module is organized into several submodules:
//! - types: Data structures and enums for pattern detection
//! - pattern_loader: Loading and management of vulnerability patterns
//! - matcher: Pattern matching logic and algorithms
//! - context_validator: Context requirement validation

pub mod context_validator;
pub mod matcher;
pub mod pattern_loader;
pub mod types;

use anyhow::Result;
use std::collections::HashMap;
use uuid::Uuid;

use crate::vulnerability_scanner::{
    config::VulnerabilityScannerConfig, DetectionMethod, VulnerabilityFinding,
};
use odincode_core::CodeFile;

// Re-export main types for convenience
pub use types::{ContextRequirement, RegexVulnerabilityPattern};

// Re-export submodules
pub use context_validator::ContextValidator;
pub use matcher::PatternMatcher;
pub use pattern_loader::PatternLoader;

/// Pattern detector for vulnerability signatures
pub struct PatternDetector {
    /// Configuration
    config: VulnerabilityScannerConfig,
    /// Pattern loader for managing vulnerability patterns
    pattern_loader: PatternLoader,
    /// Pattern matcher for executing pattern detection
    matcher: PatternMatcher,
    /// Context validator for checking pattern requirements
    context_validator: ContextValidator,
}

impl PatternDetector {
    /// Create a new pattern detector
    pub fn new(config: &VulnerabilityScannerConfig) -> Result<Self> {
        let pattern_loader = PatternLoader::new()?;
        let matcher = PatternMatcher::new(config.clone());
        let context_validator = ContextValidator::new();

        Ok(Self {
            config: config.clone(),
            pattern_loader,
            matcher,
            context_validator,
        })
    }

    /// Detect vulnerabilities using pattern matching
    pub async fn detect_vulnerabilities(
        &self,
        file: &CodeFile,
    ) -> Result<Vec<VulnerabilityFinding>> {
        if !self.config.enable_pattern_detection {
            return Ok(Vec::new());
        }

        tracing::debug!("Starting pattern detection for file: {}", file.path);

        let patterns = self
            .pattern_loader
            .get_patterns_for_language(&file.language.to_lowercase());
        let findings = self
            .matcher
            .detect_patterns(file, &patterns, &self.context_validator)?;

        // Limit findings per file
        let mut limited_findings = findings;
        if limited_findings.len() > self.config.max_findings_per_file {
            limited_findings.truncate(self.config.max_findings_per_file);
        }

        tracing::debug!(
            "Pattern detection completed for file: {}, found {} vulnerabilities",
            file.path,
            limited_findings.len()
        );

        Ok(limited_findings)
    }

    /// Get all available patterns
    pub fn get_patterns(&self) -> Vec<&RegexVulnerabilityPattern> {
        self.pattern_loader.get_all_patterns()
    }

    /// Get patterns for a specific language
    pub fn get_patterns_for_language(&self, language: &str) -> Vec<&RegexVulnerabilityPattern> {
        self.pattern_loader.get_patterns_for_language(language)
    }

    /// Add a custom pattern
    pub fn add_custom_pattern(&mut self, pattern: RegexVulnerabilityPattern) -> Result<()> {
        self.pattern_loader.add_pattern(pattern)
    }

    /// Remove a pattern by name
    pub fn remove_pattern(&mut self, pattern_name: &str) -> Result<()> {
        self.pattern_loader.remove_pattern(pattern_name)
    }

    /// Get pattern statistics
    pub fn get_statistics(&self) -> pattern_loader::PatternStatistics {
        self.pattern_loader.get_statistics()
    }

    /// Search patterns by name or description
    pub fn search_patterns(&self, query: &str) -> Vec<&RegexVulnerabilityPattern> {
        self.pattern_loader.search_patterns(query)
    }

    /// Detect patterns with detailed match information
    pub async fn detect_patterns_with_details(
        &self,
        file: &CodeFile,
    ) -> Result<Vec<matcher::PatternMatch>> {
        if !self.config.enable_pattern_detection {
            return Ok(Vec::new());
        }

        let patterns = self
            .pattern_loader
            .get_patterns_for_language(&file.language.to_lowercase());
        self.matcher
            .detect_patterns_with_details(file, &patterns, &self.context_validator)
    }

    /// Get detailed validation results for a specific context
    pub fn validate_context_with_details(
        &self,
        context: &str,
        pattern: &RegexVulnerabilityPattern,
    ) -> context_validator::ContextValidationResult {
        self.context_validator
            .validate_context_with_details(context, pattern)
    }

    /// Get patterns by category
    pub fn get_patterns_by_category(
        &self,
        category: crate::vulnerability_scanner::VulnerabilityCategory,
    ) -> Vec<&RegexVulnerabilityPattern> {
        self.pattern_loader.get_patterns_by_category(category)
    }

    /// Get patterns by severity
    pub fn get_patterns_by_severity(
        &self,
        severity: crate::vulnerability_scanner::VulnerabilitySeverity,
    ) -> Vec<&RegexVulnerabilityPattern> {
        self.pattern_loader.get_patterns_by_severity(severity)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::vulnerability_scanner::VulnerabilityScannerConfig;

    #[test]
    fn test_pattern_detector_creation() {
        let config = VulnerabilityScannerConfig::default();
        let detector = PatternDetector::new(&config).unwrap();
        assert!(!detector.get_patterns().is_empty());
    }

    #[test]
    fn test_rust_patterns() {
        let config = VulnerabilityScannerConfig::default();
        let detector = PatternDetector::new(&config).unwrap();
        let rust_patterns = detector.get_patterns_for_language("rust");
        assert!(!rust_patterns.is_empty());

        // Check for specific Rust patterns
        let unsafe_pattern = rust_patterns.iter().find(|p| p.name == "rust_unsafe_block");
        assert!(unsafe_pattern.is_some());

        let raw_ptr_pattern = rust_patterns
            .iter()
            .find(|p| p.name == "rust_raw_pointer_dereference");
        assert!(raw_ptr_pattern.is_some());
    }

    #[test]
    fn test_python_patterns() {
        let config = VulnerabilityScannerConfig::default();
        let detector = PatternDetector::new(&config).unwrap();
        let python_patterns = detector.get_patterns_for_language("python");
        assert!(!python_patterns.is_empty());

        // Check for specific Python patterns
        let eval_pattern = python_patterns
            .iter()
            .find(|p| p.name == "python_eval_usage");
        assert!(eval_pattern.is_some());

        let pickle_pattern = python_patterns
            .iter()
            .find(|p| p.name == "python_pickle_usage");
        assert!(pickle_pattern.is_some());
    }

    #[test]
    fn test_custom_pattern_management() {
        let config = VulnerabilityScannerConfig::default();
        let mut detector = PatternDetector::new(&config).unwrap();

        let initial_count = detector.get_patterns().len();

        // Add custom pattern
        let custom_pattern = RegexVulnerabilityPattern::new(
            "custom_test".to_string(),
            "Custom test pattern".to_string(),
            regex::Regex::new(r"custom_test").unwrap(),
            crate::vulnerability_scanner::VulnerabilityCategory::CodeQuality,
            crate::vulnerability_scanner::VulnerabilitySeverity::Low,
            0.5,
            "Custom fix".to_string(),
            None,
            ["test"].iter().map(|s| s.to_string()).collect(),
            vec![],
        );

        detector.add_custom_pattern(custom_pattern).unwrap();
        assert_eq!(detector.get_patterns().len(), initial_count + 1);

        // Remove pattern
        detector.remove_pattern("custom_test").unwrap();
        assert_eq!(detector.get_patterns().len(), initial_count);
    }

    #[test]
    fn test_pattern_statistics() {
        let config = VulnerabilityScannerConfig::default();
        let detector = PatternDetector::new(&config).unwrap();
        let stats = detector.get_statistics();

        assert!(stats.total_patterns > 0);
        assert!(!stats.category_counts.is_empty());
        assert!(!stats.severity_counts.is_empty());
        assert!(!stats.language_counts.is_empty());
    }

    #[test]
    fn test_search_patterns() {
        let config = VulnerabilityScannerConfig::default();
        let detector = PatternDetector::new(&config).unwrap();
        let results = detector.search_patterns("unsafe");
        assert!(!results.is_empty());

        let results = detector.search_patterns("nonexistent");
        assert!(results.is_empty());
    }

    #[test]
    fn test_patterns_by_category() {
        let config = VulnerabilityScannerConfig::default();
        let detector = PatternDetector::new(&config).unwrap();
        let security_patterns = detector.get_patterns_by_category(
            crate::vulnerability_scanner::VulnerabilityCategory::Security,
        );
        assert!(!security_patterns.is_empty());
    }

    #[test]
    fn test_patterns_by_severity() {
        let config = VulnerabilityScannerConfig::default();
        let detector = PatternDetector::new(&config).unwrap();
        let critical_patterns = detector.get_patterns_by_severity(
            crate::vulnerability_scanner::VulnerabilitySeverity::Critical,
        );
        assert!(!critical_patterns.is_empty());
    }
}
