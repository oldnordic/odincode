//! ML Model Manager
//!
//! This module handles loading, managing, and configuring ML models
//! for vulnerability detection.

use anyhow::Result;
use std::collections::HashMap;

use crate::vulnerability_scanner::ml_detector::types::{FeatureConfig, ModelConfig, ModelType};

/// ML model manager
pub struct ModelManager {
    /// Loaded ML models
    models: HashMap<String, ModelConfig>,
    /// Model ensemble weights
    ensemble_weights: HashMap<String, f64>,
}

impl ModelManager {
    /// Create a new model manager
    pub fn new(model_path: &std::path::PathBuf) -> Result<Self> {
        let models = Self::load_models(model_path)?;
        let ensemble_weights = Self::load_ensemble_weights()?;

        Ok(Self {
            models,
            ensemble_weights,
        })
    }

    /// Load ML models from the model path
    fn load_models(model_path: &std::path::PathBuf) -> Result<HashMap<String, ModelConfig>> {
        let mut models = HashMap::new();

        // In a real implementation, you would load actual ML model files
        // For now, we'll create placeholder configurations

        models.insert(
            "vulnerability_classifier".to_string(),
            ModelConfig {
                model_type: ModelType::Ensemble,
                model_path: model_path
                    .join("vulnerability_classifier.bin")
                    .to_string_lossy()
                    .to_string(),
                feature_config: FeatureConfig {
                    lexical_features: true,
                    syntactic_features: true,
                    semantic_features: true,
                    code_metrics_features: true,
                    data_flow_features: true,
                    control_flow_features: true,
                },
                threshold: 0.7,
                version: "1.0.0".to_string(),
            },
        );

        models.insert(
            "security_classifier".to_string(),
            ModelConfig {
                model_type: ModelType::RandomForest,
                model_path: model_path
                    .join("security_classifier.bin")
                    .to_string_lossy()
                    .to_string(),
                feature_config: FeatureConfig {
                    lexical_features: true,
                    syntactic_features: true,
                    semantic_features: false,
                    code_metrics_features: true,
                    data_flow_features: true,
                    control_flow_features: false,
                },
                threshold: 0.8,
                version: "1.0.0".to_string(),
            },
        );

        models.insert(
            "memory_safety_classifier".to_string(),
            ModelConfig {
                model_type: ModelType::NeuralNetwork,
                model_path: model_path
                    .join("memory_safety_classifier.bin")
                    .to_string_lossy()
                    .to_string(),
                feature_config: FeatureConfig {
                    lexical_features: true,
                    syntactic_features: true,
                    semantic_features: true,
                    code_metrics_features: false,
                    data_flow_features: true,
                    control_flow_features: true,
                },
                threshold: 0.75,
                version: "1.0.0".to_string(),
            },
        );

        Ok(models)
    }

    /// Load ensemble weights for model combination
    fn load_ensemble_weights() -> Result<HashMap<String, f64>> {
        let mut weights = HashMap::new();

        // Weights for different models in the ensemble
        weights.insert("vulnerability_classifier".to_string(), 0.5);
        weights.insert("security_classifier".to_string(), 0.3);
        weights.insert("memory_safety_classifier".to_string(), 0.2);

        Ok(weights)
    }

    /// Get available models
    pub fn get_models(&self) -> &HashMap<String, ModelConfig> {
        &self.models
    }

    /// Get ensemble weights
    pub fn get_ensemble_weights(&self) -> &HashMap<String, f64> {
        &self.ensemble_weights
    }

    /// Add a new model
    pub fn add_model(&mut self, name: String, model_config: ModelConfig) -> Result<()> {
        self.models.insert(name, model_config);
        Ok(())
    }

    /// Remove a model
    pub fn remove_model(&mut self, name: &str) -> Result<()> {
        self.models.remove(name);
        Ok(())
    }

    /// Update ensemble weights
    pub fn update_ensemble_weights(&mut self, weights: HashMap<String, f64>) -> Result<()> {
        // Normalize weights to sum to 1.0
        let total_weight: f64 = weights.values().sum();
        if total_weight > 0.0 {
            self.ensemble_weights = weights
                .into_iter()
                .map(|(k, v)| (k, v / total_weight))
                .collect();
        }
        Ok(())
    }

    /// Get model configuration by name
    pub fn get_model_config(&self, name: &str) -> Option<&ModelConfig> {
        self.models.get(name)
    }

    /// Get model weight by name
    pub fn get_model_weight(&self, name: &str) -> Option<f64> {
        self.ensemble_weights.get(name).copied()
    }

    /// Check if a model exists
    pub fn has_model(&self, name: &str) -> bool {
        self.models.contains_key(name)
    }

    /// Get total number of models
    pub fn model_count(&self) -> usize {
        self.models.len()
    }

    /// Get model names
    pub fn model_names(&self) -> Vec<String> {
        self.models.keys().cloned().collect()
    }
}
