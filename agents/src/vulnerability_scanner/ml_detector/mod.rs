//! Machine Learning Detector for Advanced Vulnerability Detection
//!
//! This module implements ML-based vulnerability detection using
//! pre-trained models and advanced machine learning techniques.

pub mod feature_extractor;
pub mod model_manager;
pub mod prediction_engine;
pub mod types;

use anyhow::Result;
use std::collections::HashMap;

use crate::vulnerability_scanner::{
    config::VulnerabilityScannerConfig, VulnerabilityCategory, VulnerabilityFinding,
};
use odincode_core::CodeFile;

// Re-export main types for convenience
pub use feature_extractor::MLFeatureExtractor;
pub use model_manager::ModelManager;
pub use prediction_engine::PredictionEngine;
pub use types::{
    FeatureConfig, FeatureVector, LanguageFeatureExtractor, ModelConfig, ModelType,
    PredictionResult,
};

/// Machine learning detector
pub struct MLDetector {
    /// Configuration
    config: VulnerabilityScannerConfig,
    /// Model manager
    model_manager: ModelManager,
    /// Feature extractor
    feature_extractor: MLFeatureExtractor,
    /// Prediction engine
    prediction_engine: PredictionEngine,
}

impl MLDetector {
    /// Create a new ML detector
    pub fn new(config: &VulnerabilityScannerConfig) -> Result<Self> {
        let model_manager = ModelManager::new(&config.model_path)?;
        let feature_extractor = MLFeatureExtractor::new(&FeatureConfig {
            lexical_features: true,
            syntactic_features: true,
            semantic_features: true,
            code_metrics_features: true,
            data_flow_features: true,
            control_flow_features: true,
        })?;

        let ensemble_weights = model_manager.get_ensemble_weights().clone();
        let prediction_engine = PredictionEngine::new(ensemble_weights);

        Ok(Self {
            config: config.clone(),
            model_manager,
            feature_extractor,
            prediction_engine,
        })
    }

    /// Detect vulnerabilities using ML models
    pub async fn detect_vulnerabilities(
        &self,
        file: &CodeFile,
    ) -> Result<Vec<VulnerabilityFinding>> {
        if !self.config.enable_ml_detection {
            return Ok(Vec::new());
        }

        tracing::debug!("Starting ML detection for file: {}", file.path);

        let mut findings = Vec::new();

        // Extract features from the file
        let feature_vectors = self.feature_extractor.extract_features(file).await?;

        // Run predictions for each model
        let mut predictions = Vec::new();
        for (model_name, model_config) in self.model_manager.get_models() {
            if let Ok(prediction) = self
                .prediction_engine
                .predict_with_model(model_config, &feature_vectors)
            {
                predictions.push((model_name.clone(), prediction));
            }
        }

        // Combine predictions using ensemble method
        let ensemble_predictions = self.prediction_engine.combine_predictions(&predictions);

        // Convert predictions to findings
        for (line_num, prediction) in ensemble_predictions {
            if prediction.predicted_class
                && prediction.confidence >= self.config.confidence_threshold
            {
                let finding = self.prediction_engine.create_finding_from_prediction(
                    file,
                    line_num,
                    prediction,
                    self.config.confidence_threshold,
                )?;
                findings.push(finding);
            }
        }

        // Limit findings per file
        if findings.len() > self.config.max_findings_per_file {
            findings.truncate(self.config.max_findings_per_file);
        }

        tracing::debug!(
            "ML detection completed for file: {}, found {} vulnerabilities",
            file.path,
            findings.len()
        );

        Ok(findings)
    }

    /// Get available models
    pub fn get_models(&self) -> &HashMap<String, ModelConfig> {
        self.model_manager.get_models()
    }

    /// Add a new model
    pub fn add_model(&mut self, name: String, model_config: ModelConfig) -> Result<()> {
        self.model_manager.add_model(name, model_config)?;
        // Update prediction engine with new weights
        let ensemble_weights = self.model_manager.get_ensemble_weights().clone();
        self.prediction_engine = PredictionEngine::new(ensemble_weights);
        Ok(())
    }

    /// Remove a model
    pub fn remove_model(&mut self, name: &str) -> Result<()> {
        self.model_manager.remove_model(name)?;
        // Update prediction engine with new weights
        let ensemble_weights = self.model_manager.get_ensemble_weights().clone();
        self.prediction_engine = PredictionEngine::new(ensemble_weights);
        Ok(())
    }

    /// Update ensemble weights
    pub fn update_ensemble_weights(&mut self, weights: HashMap<String, f64>) -> Result<()> {
        self.model_manager.update_ensemble_weights(weights)?;
        // Update prediction engine with new weights
        let ensemble_weights = self.model_manager.get_ensemble_weights().clone();
        self.prediction_engine = PredictionEngine::new(ensemble_weights);
        Ok(())
    }

    /// Get model count
    pub fn model_count(&self) -> usize {
        self.model_manager.model_count()
    }

    /// Get model names
    pub fn model_names(&self) -> Vec<String> {
        self.model_manager.model_names()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::vulnerability_scanner::VulnerabilityScannerConfig;

    #[test]
    fn test_ml_detector_creation() {
        let config = VulnerabilityScannerConfig::default();
        let detector = MLDetector::new(&config).unwrap();
        assert!(!detector.get_models().is_empty());
    }

    #[tokio::test]
    async fn test_feature_extraction() {
        let feature_config = FeatureConfig {
            lexical_features: true,
            syntactic_features: true,
            semantic_features: true,
            code_metrics_features: true,
            data_flow_features: true,
            control_flow_features: true,
        };

        let extractor = MLFeatureExtractor::new(&feature_config).unwrap();

        let rust_file = CodeFile {
            id: uuid::Uuid::new_v4(),
            path: "test.rs".to_string(),
            content: "unsafe { let ptr = &mut x as *mut i32; }".to_string(),
            language: "rust".to_string(),
            modified: chrono::Utc::now(),
        };
        let features = extractor.extract_features(&rust_file).await.unwrap();
        assert!(!features.is_empty());

        let python_file = CodeFile {
            id: uuid::Uuid::new_v4(),
            path: "test.py".to_string(),
            content: "def eval_input(user_input): return eval(user_input)".to_string(),
            language: "python".to_string(),
            modified: chrono::Utc::now(),
        };
        let features = extractor.extract_features(&python_file).await.unwrap();
        assert!(!features.is_empty());
    }

    #[test]
    fn test_prediction_combination() {
        let config = VulnerabilityScannerConfig::default();
        let mut detector = MLDetector::new(&config).unwrap();

        // Override ensemble weights for test to ensure they exist
        let mut weights = HashMap::new();
        weights.insert("model1".to_string(), 0.5);
        weights.insert("model2".to_string(), 0.5);
        detector.update_ensemble_weights(weights).unwrap();

        let prediction1 = PredictionResult {
            predicted_class: true,
            confidence: 0.8,
            probabilities: {
                let mut probs = HashMap::new();
                probs.insert("vulnerable".to_string(), 0.8);
                probs.insert("safe".to_string(), 0.2);
                probs
            },
            feature_importance: {
                let mut importance = HashMap::new();
                importance.insert("feature1".to_string(), 0.5);
                importance.insert("feature2".to_string(), 0.3);
                importance
            },
            explanation: "Test prediction 1".to_string(),
        };

        let prediction2 = PredictionResult {
            predicted_class: true,
            confidence: 0.9,
            probabilities: {
                let mut probs = HashMap::new();
                probs.insert("vulnerable".to_string(), 0.9);
                probs.insert("safe".to_string(), 0.1);
                probs
            },
            feature_importance: {
                let mut importance = HashMap::new();
                importance.insert("feature1".to_string(), 0.4);
                importance.insert("feature3".to_string(), 0.4);
                importance
            },
            explanation: "Test prediction 2".to_string(),
        };

        let predictions = vec![
            ("model1".to_string(), prediction1),
            ("model2".to_string(), prediction2),
        ];

        let combined = detector.prediction_engine.combine_predictions(&predictions);
        assert!(!combined.is_empty());

        let combined_prediction = combined.get(&0).unwrap();
        assert!(combined_prediction.predicted_class);
        assert!(combined_prediction.confidence > 0.8);
    }

    #[test]
    fn test_category_determination() {
        let config = VulnerabilityScannerConfig::default();
        let detector = MLDetector::new(&config).unwrap();

        let mut feature_importance = HashMap::new();
        feature_importance.insert("security_feature".to_string(), 0.8);
        feature_importance.insert("input_validation".to_string(), 0.6);

        let category = detector
            .prediction_engine
            .determine_category_from_features(&feature_importance);
        assert_eq!(category, VulnerabilityCategory::Security);

        let mut feature_importance = HashMap::new();
        feature_importance.insert("memory_feature".to_string(), 0.7);
        feature_importance.insert("buffer_overflow".to_string(), 0.5);

        let category = detector
            .prediction_engine
            .determine_category_from_features(&feature_importance);
        assert_eq!(category, VulnerabilityCategory::MemorySafety);
    }
}
