//! ML Feature Extractor
//!
//! This module implements feature extraction from code for ML-based vulnerability detection.
//! Supports multiple programming languages with language-specific feature extraction.

use anyhow::Result;
use std::collections::HashMap;

use crate::vulnerability_scanner::ml_detector::types::{
    FeatureConfig, FeatureVector, LanguageFeatureExtractor,
};
use odincode_core::CodeFile;

/// ML feature extractor
pub struct MLFeatureExtractor {
    /// Feature configuration
    feature_config: FeatureConfig,
    /// Language-specific extractors
    language_extractors: HashMap<String, LanguageFeatureExtractor>,
}

impl MLFeatureExtractor {
    /// Create a new ML feature extractor
    pub fn new(feature_config: &FeatureConfig) -> Result<Self> {
        let mut language_extractors = HashMap::new();

        // Initialize language-specific extractors
        language_extractors.insert(
            "rust".to_string(),
            Self::create_rust_extractor(feature_config),
        );
        language_extractors.insert(
            "python".to_string(),
            Self::create_python_extractor(feature_config),
        );
        language_extractors.insert(
            "javascript".to_string(),
            Self::create_javascript_extractor(feature_config),
        );
        language_extractors.insert(
            "typescript".to_string(),
            Self::create_typescript_extractor(feature_config),
        );
        language_extractors.insert("go".to_string(), Self::create_go_extractor(feature_config));

        Ok(Self {
            feature_config: feature_config.clone(),
            language_extractors,
        })
    }

    /// Create Rust feature extractor
    fn create_rust_extractor(feature_config: &FeatureConfig) -> LanguageFeatureExtractor {
        let mut extractors: HashMap<
            String,
            std::sync::Arc<dyn Fn(&str, &str) -> Vec<f32> + Send + Sync>,
        > = HashMap::new();

        if feature_config.lexical_features {
            let lexical_fn: std::sync::Arc<dyn Fn(&str, &str) -> Vec<f32> + Send + Sync> =
                std::sync::Arc::new(|code: &str, _| {
                    vec![
                        (code.len() as f32).min(1000.0) / 1000.0, // Normalized length
                        (code.matches("unsafe").count() as f32).min(10.0) / 10.0, // Unsafe usage
                        (code.matches("mut").count() as f32).min(20.0) / 20.0, // Mutable usage
                        (code.matches("pub").count() as f32).min(15.0) / 15.0, // Public items
                    ]
                });
            extractors.insert("lexical_features".to_string(), lexical_fn);
        }

        if feature_config.semantic_features {
            let semantic_fn: std::sync::Arc<dyn Fn(&str, &str) -> Vec<f32> + Send + Sync> =
                std::sync::Arc::new(|code: &str, _| {
                    vec![
                        if code.contains("Vec") { 1.0 } else { 0.0 }, // Vector usage
                        if code.contains("String") { 1.0 } else { 0.0 }, // String usage
                        if code.contains("Option") { 1.0 } else { 0.0 }, // Option usage
                        if code.contains("Result") { 1.0 } else { 0.0 }, // Result usage
                        if code.contains("Box") { 1.0 } else { 0.0 }, // Box usage
                    ]
                });
            extractors.insert("semantic_features".to_string(), semantic_fn);
        }

        LanguageFeatureExtractor {
            language: "rust".to_string(),
            feature_types: extractors.keys().cloned().collect(),
            extractors,
        }
    }

    /// Create Python feature extractor
    fn create_python_extractor(feature_config: &FeatureConfig) -> LanguageFeatureExtractor {
        let mut extractors: HashMap<
            String,
            std::sync::Arc<dyn Fn(&str, &str) -> Vec<f32> + Send + Sync>,
        > = HashMap::new();

        if feature_config.lexical_features {
            let lexical_fn: std::sync::Arc<dyn Fn(&str, &str) -> Vec<f32> + Send + Sync> =
                std::sync::Arc::new(|code: &str, _| {
                    vec![
                        (code.len() as f32).min(1000.0) / 1000.0, // Normalized length
                        (code.matches("import").count() as f32).min(20.0) / 20.0, // Imports
                        (code.matches("def").count() as f32).min(15.0) / 15.0, // Functions
                        (code.matches("class").count() as f32).min(10.0) / 10.0, // Classes
                    ]
                });
            extractors.insert("lexical_features".to_string(), lexical_fn);
        }

        if feature_config.syntactic_features {
            let syntactic_fn: std::sync::Arc<dyn Fn(&str, &str) -> Vec<f32> + Send + Sync> =
                std::sync::Arc::new(|code: &str, _| {
                    vec![
                        (code.matches(':').count() as f32).min(50.0) / 50.0, // Colons
                        (code.matches('(').count() as f32).min(30.0) / 30.0, // Parentheses
                        (code.matches("    ").count() as f32).min(100.0) / 100.0, // Indentation
                        (code.matches(',').count() as f32).min(50.0) / 50.0, // Commas
                    ]
                });
            extractors.insert("syntactic_features".to_string(), syntactic_fn);
        }

        if feature_config.semantic_features {
            let semantic_fn: std::sync::Arc<dyn Fn(&str, &str) -> Vec<f32> + Send + Sync> =
                std::sync::Arc::new(|code: &str, _| {
                    vec![
                        if code.contains("list") { 1.0 } else { 0.0 }, // List usage
                        if code.contains("dict") { 1.0 } else { 0.0 }, // Dict usage
                        if code.contains("try") { 1.0 } else { 0.0 },  // Exception handling
                        if code.contains("with") { 1.0 } else { 0.0 }, // Context manager
                        if code.contains("lambda") { 1.0 } else { 0.0 }, // Lambda usage
                    ]
                });
            extractors.insert("semantic_features".to_string(), semantic_fn);
        }

        LanguageFeatureExtractor {
            language: "python".to_string(),
            feature_types: extractors.keys().cloned().collect(),
            extractors,
        }
    }

    /// Create JavaScript feature extractor
    fn create_javascript_extractor(feature_config: &FeatureConfig) -> LanguageFeatureExtractor {
        let mut extractors: HashMap<
            String,
            std::sync::Arc<dyn Fn(&str, &str) -> Vec<f32> + Send + Sync>,
        > = HashMap::new();

        if feature_config.lexical_features {
            let lexical_fn: std::sync::Arc<dyn Fn(&str, &str) -> Vec<f32> + Send + Sync> =
                std::sync::Arc::new(|code: &str, _| {
                    vec![
                        (code.len() as f32).min(1000.0) / 1000.0, // Normalized length
                        (code.matches("function").count() as f32).min(20.0) / 20.0, // Functions
                        (code.matches("var").count() as f32).min(15.0) / 15.0, // Var usage
                        (code.matches("let").count() as f32).min(15.0) / 15.0, // Let usage
                        (code.matches("const").count() as f32).min(15.0) / 15.0, // Const usage
                    ]
                });
            extractors.insert("lexical_features".to_string(), lexical_fn);
        }

        if feature_config.syntactic_features {
            let syntactic_fn: std::sync::Arc<dyn Fn(&str, &str) -> Vec<f32> + Send + Sync> =
                std::sync::Arc::new(|code: &str, _| {
                    vec![
                        (code.matches(':').count() as f32).min(50.0) / 50.0, // Colons
                        (code.matches('(').count() as f32).min(30.0) / 30.0, // Parentheses
                        (code.matches("    ").count() as f32).min(100.0) / 100.0, // Indentation
                        (code.matches(',').count() as f32).min(50.0) / 50.0, // Commas
                    ]
                });
            extractors.insert("syntactic_features".to_string(), syntactic_fn);
        }

        if feature_config.semantic_features {
            let semantic_fn: std::sync::Arc<dyn Fn(&str, &str) -> Vec<f32> + Send + Sync> =
                std::sync::Arc::new(|code: &str, _| {
                    vec![
                        if code.contains("Array") { 1.0 } else { 0.0 }, // Array usage
                        if code.contains("Object") { 1.0 } else { 0.0 }, // Object usage
                        if code.contains("Promise") { 1.0 } else { 0.0 }, // Promise usage
                        if code.contains("async") { 1.0 } else { 0.0 }, // Async usage
                        if code.contains("await") { 1.0 } else { 0.0 }, // Await usage
                    ]
                });
            extractors.insert("semantic_features".to_string(), semantic_fn);
        }

        LanguageFeatureExtractor {
            language: "javascript".to_string(),
            feature_types: extractors.keys().cloned().collect(),
            extractors,
        }
    }

    /// Create TypeScript feature extractor
    fn create_typescript_extractor(feature_config: &FeatureConfig) -> LanguageFeatureExtractor {
        let mut js_extractor = Self::create_javascript_extractor(feature_config);

        // Add TypeScript-specific features
        let typescript_fn: std::sync::Arc<dyn Fn(&str, &str) -> Vec<f32> + Send + Sync> =
            std::sync::Arc::new(|code: &str, _| {
                vec![
                    (code.matches(":").count() as f32).min(50.0) / 50.0, // Type annotations
                    (code.matches("interface").count() as f32).min(10.0) / 10.0, // Interfaces
                    (code.matches("type").count() as f32).min(15.0) / 15.0, // Type aliases
                    (code.matches("extends").count() as f32).min(10.0) / 10.0, // Extends
                    (code.matches("implements").count() as f32).min(10.0) / 10.0, // Implements
                ]
            });
        js_extractor
            .extractors
            .insert("typescript_features".to_string(), typescript_fn);

        js_extractor
    }

    /// Create Go feature extractor
    fn create_go_extractor(feature_config: &FeatureConfig) -> LanguageFeatureExtractor {
        let mut extractors: HashMap<
            String,
            std::sync::Arc<dyn Fn(&str, &str) -> Vec<f32> + Send + Sync>,
        > = HashMap::new();

        if feature_config.lexical_features {
            let lexical_fn: std::sync::Arc<dyn Fn(&str, &str) -> Vec<f32> + Send + Sync> =
                std::sync::Arc::new(|code: &str, _| {
                    vec![
                        (code.len() as f32).min(1000.0) / 1000.0, // Normalized length
                        (code.matches("func").count() as f32).min(20.0) / 20.0, // Functions
                        (code.matches("var").count() as f32).min(15.0) / 15.0, // Var usage
                        (code.matches("const").count() as f32).min(15.0) / 15.0, // Const usage
                        (code.matches("type").count() as f32).min(15.0) / 15.0, // Type usage
                    ]
                });
            extractors.insert("lexical_features".to_string(), lexical_fn);
        }

        if feature_config.syntactic_features {
            let syntactic_fn: std::sync::Arc<dyn Fn(&str, &str) -> Vec<f32> + Send + Sync> =
                std::sync::Arc::new(|code: &str, _| {
                    vec![
                        (code.matches('{').count() as f32).min(50.0) / 50.0, // Braces
                        (code.matches('(').count() as f32).min(30.0) / 30.0, // Parentheses
                        (code.matches("package").count() as f32).min(5.0) / 5.0, // Package declarations
                        (code.matches("import").count() as f32).min(20.0) / 20.0, // Imports
                    ]
                });
            extractors.insert("syntactic_features".to_string(), syntactic_fn);
        }

        if feature_config.semantic_features {
            let semantic_fn: std::sync::Arc<dyn Fn(&str, &str) -> Vec<f32> + Send + Sync> =
                std::sync::Arc::new(|code, _| {
                    vec![
                        if code.contains("goroutine") { 1.0 } else { 0.0 }, // Goroutine usage
                        if code.contains("channel") { 1.0 } else { 0.0 },   // Channel usage
                        if code.contains("defer") { 1.0 } else { 0.0 },     // Defer usage
                        if code.contains("select") { 1.0 } else { 0.0 },    // Select usage
                        if code.contains("interface") { 1.0 } else { 0.0 }, // Interface usage
                    ]
                });
            extractors.insert("semantic_features".to_string(), semantic_fn);
        }

        LanguageFeatureExtractor {
            language: "go".to_string(),
            feature_types: extractors.keys().cloned().collect(),
            extractors,
        }
    }

    /// Extract features from code file
    pub async fn extract_features(&self, file: &CodeFile) -> Result<Vec<FeatureVector>> {
        let language = file.language.to_lowercase();
        let extractor = self
            .language_extractors
            .get(&language)
            .ok_or_else(|| anyhow::anyhow!("Unsupported language: {}", language))?;

        let mut feature_vectors = Vec::new();
        let lines: Vec<&str> = file.content.lines().collect();

        // Extract features for each line
        for (line_num, line) in lines.iter().enumerate() {
            let mut all_features = Vec::new();
            let mut all_names = Vec::new();

            // Extract features for each feature type
            for (feature_type, extract_fn) in &extractor.extractors {
                let features = extract_fn(line, &language);
                for (i, feature) in features.iter().enumerate() {
                    all_features.push(*feature);
                    all_names.push(format!("{}_{}_{}", feature_type, line_num, i));
                }
            }

            // Calculate feature importance (simplified)
            let importance: Vec<f32> = all_features.iter().map(|&f| f.abs()).collect();

            feature_vectors.push(FeatureVector {
                values: all_features,
                names: all_names,
                importance,
            });
        }

        Ok(feature_vectors)
    }
}
