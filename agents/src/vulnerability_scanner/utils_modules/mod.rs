//! Utility functions for the vulnerability scanner
//!
//! This module contains utility functions and helpers for the AEGIS-BUGS
//! vulnerability scanner system, organized into logical submodules.

// Re-export all modules
pub mod code_analyzers;
pub mod function_extractors;
pub mod types;
pub mod vulnerability_helpers;

// Re-export commonly used types and structs for convenience
pub use types::{
    AnalysisConfig, AnalysisResult, ComplexityMetrics, FileAnalysis, FunctionSignature,
    ImportStatement, LanguageDetection, PatternMatch, QualityAssessment, QualityIssue,
    QualityIssueSeverity, QualityIssueType,
};

pub use code_analyzers::{ComplexityAnalyzer, FileAnalyzer, PatternDetector, QualityAssessor};
pub use function_extractors::{FunctionExtractor, ImportExtractor, LanguageDetector};
pub use vulnerability_helpers::{ReportUtils, ScoringUtils, VulnerabilitySummary};

// Legacy re-exports for backward compatibility
pub use code_analyzers::FileAnalyzer as FileUtils;
pub use function_extractors::FunctionExtractor as CodeAnalysisUtils;

/// Main utility orchestrator for vulnerability scanner
pub struct VulnerabilityScannerUtils;

impl VulnerabilityScannerUtils {
    /// Create a new analysis configuration with defaults
    pub fn default_config() -> AnalysisConfig {
        AnalysisConfig::default()
    }

    /// Create a custom analysis configuration
    pub fn create_config(
        max_file_size: usize,
        max_line_length: usize,
        max_cyclomatic_complexity: usize,
        max_nesting_depth: usize,
        min_maintainability_index: f64,
    ) -> AnalysisConfig {
        AnalysisConfig {
            max_file_size,
            max_line_length,
            max_cyclomatic_complexity,
            max_nesting_depth,
            min_maintainability_index,
            ..AnalysisConfig::default()
        }
    }

    /// Analyze a file with comprehensive analysis
    pub fn analyze_file(
        file_path: &str,
        config: &AnalysisConfig,
    ) -> Result<AnalysisResult, anyhow::Error> {
        use std::path::Path;
        use std::time::Instant;

        let start_time = Instant::now();
        let path = Path::new(file_path);
        let mut errors = Vec::new();

        // Basic file analysis
        let file_analysis = match FileAnalyzer::analyze_file(path, config) {
            Ok(analysis) => analysis,
            Err(e) => {
                errors.push(format!("File analysis failed: {}", e));
                FileAnalysis::default()
            }
        };

        // Quality assessment if enabled
        let quality_assessment = if config.enable_quality_assessment {
            match QualityAssessor::assess_quality(&file_analysis, config) {
                Ok(assessment) => Some(assessment),
                Err(e) => {
                    errors.push(format!("Quality assessment failed: {}", e));
                    None
                }
            }
        } else {
            None
        };

        let analysis_duration_ms = start_time.elapsed().as_millis() as u64;

        Ok(AnalysisResult {
            file_path: file_path.to_string(),
            config: config.clone(),
            file_analysis,
            quality_assessment,
            analysis_duration_ms,
            analyzed_at: chrono::Utc::now().to_rfc3339(),
            errors,
        })
    }

    /// Extract function signatures from code
    pub fn extract_function_signatures(code: &str, language: &str) -> Vec<FunctionSignature> {
        FunctionExtractor::extract_signatures(code, language)
    }

    /// Extract imports from code
    pub fn extract_imports(code: &str, language: &str) -> Vec<ImportStatement> {
        ImportExtractor::extract_imports(code, language)
    }

    /// Detect language from file path
    pub fn detect_language(file_path: &str) -> Option<LanguageDetection> {
        use std::path::Path;
        LanguageDetector::from_file_path(Path::new(file_path))
    }

    /// Calculate complexity metrics for code
    pub fn calculate_complexity_metrics(code: &str) -> ComplexityMetrics {
        ComplexityAnalyzer::calculate_metrics(code)
    }

    /// Detect patterns in code
    pub fn detect_patterns(code: &str, patterns: &[String]) -> Vec<PatternMatch> {
        PatternDetector::detect_patterns(code, patterns)
    }

    /// Generate vulnerability summary
    pub fn generate_vulnerability_summary(
        findings: &[crate::vulnerability_scanner::VulnerabilityFinding],
    ) -> VulnerabilitySummary {
        ReportUtils::generate_summary(findings)
    }

    /// Generate markdown vulnerability report
    pub fn generate_markdown_report(
        findings: &[crate::vulnerability_scanner::VulnerabilityFinding],
        file_path: &str,
    ) -> String {
        ReportUtils::generate_markdown_report(findings, file_path)
    }

    /// Generate JSON vulnerability report
    pub fn generate_json_report(
        findings: &[crate::vulnerability_scanner::VulnerabilityFinding],
        file_path: &str,
    ) -> Result<String, anyhow::Error> {
        ReportUtils::generate_json_report(findings, file_path)
    }

    /// Calculate risk score for vulnerability
    pub fn calculate_risk_score(
        severity: &crate::vulnerability_scanner::VulnerabilitySeverity,
        category: &crate::vulnerability_scanner::VulnerabilityCategory,
        confidence: f64,
        complexity: &ComplexityMetrics,
    ) -> f64 {
        ScoringUtils::calculate_risk_score(severity, category, confidence, complexity)
    }

    /// Prioritize vulnerabilities
    pub fn prioritize_vulnerabilities(
        findings: &mut [crate::vulnerability_scanner::VulnerabilityFinding],
    ) {
        ScoringUtils::prioritize_vulnerabilities(findings);
    }

    /// Group vulnerabilities by category
    pub fn group_vulnerabilities_by_category(
        findings: &[crate::vulnerability_scanner::VulnerabilityFinding],
    ) -> std::collections::HashMap<
        crate::vulnerability_scanner::VulnerabilityCategory,
        Vec<crate::vulnerability_scanner::VulnerabilityFinding>,
    > {
        ScoringUtils::group_by_category(findings)
    }

    /// Group vulnerabilities by severity
    pub fn group_vulnerabilities_by_severity(
        findings: &[crate::vulnerability_scanner::VulnerabilityFinding],
    ) -> std::collections::HashMap<
        crate::vulnerability_scanner::VulnerabilitySeverity,
        Vec<crate::vulnerability_scanner::VulnerabilityFinding>,
    > {
        ScoringUtils::group_by_severity(findings)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default_config() {
        let config = VulnerabilityScannerUtils::default_config();
        assert_eq!(config.max_file_size, 1024 * 1024);
        assert_eq!(config.max_line_length, 100);
        assert!(config.enable_pattern_detection);
    }

    #[test]
    fn test_create_config() {
        let config = VulnerabilityScannerUtils::create_config(2048, 120, 15, 5, 70.0);
        assert_eq!(config.max_file_size, 2048);
        assert_eq!(config.max_line_length, 120);
        assert_eq!(config.max_cyclomatic_complexity, 15);
        assert_eq!(config.max_nesting_depth, 5);
        assert_eq!(config.min_maintainability_index, 70.0);
    }

    #[test]
    fn test_extract_function_signatures() {
        let rust_code = r#"
            fn main() {
                println!("Hello, world!");
            }
            
            pub fn add(a: i32, b: i32) -> i32 {
                a + b
            }
        "#;

        let signatures = VulnerabilityScannerUtils::extract_function_signatures(rust_code, "rust");
        assert_eq!(signatures.len(), 2);
        assert!(signatures[0].signature.contains("fn main"));
        assert!(signatures[1].signature.contains("pub fn add"));
    }

    #[test]
    fn test_extract_imports() {
        let rust_code = r#"
            use std::collections::HashMap;
            use std::fs::File;
        "#;

        let imports = VulnerabilityScannerUtils::extract_imports(rust_code, "rust");
        assert_eq!(imports.len(), 2);
        assert!(imports[0].module.contains("std::collections"));
    }

    #[test]
    fn test_detect_language() {
        let detection = VulnerabilityScannerUtils::detect_language("test.rs");
        assert!(detection.is_some());
        assert_eq!(detection.unwrap().language, "rust");
    }

    #[test]
    fn test_calculate_complexity_metrics() {
        let code = r#"
            fn test(x: i32) -> i32 {
                if x > 0 {
                    return x + 1;
                }
                x
            }
        "#;

        let metrics = VulnerabilityScannerUtils::calculate_complexity_metrics(code);
        assert!(metrics.cyclomatic_complexity > 1);
        assert!(metrics.total_lines > 0);
    }

    #[test]
    fn test_detect_patterns() {
        let code = r#"
            fn main() {
                println!("Hello");
                panic!("Error");
            }
        "#;

        let patterns = vec![r"panic!\(".to_string()];
        let matches = VulnerabilityScannerUtils::detect_patterns(code, &patterns);
        assert_eq!(matches.len(), 1);
        assert!(matches[0].matched_text.contains("panic!"));
    }

    #[test]
    fn test_calculate_risk_score() {
        use crate::vulnerability_scanner::{VulnerabilityCategory, VulnerabilitySeverity};

        let complexity = ComplexityMetrics {
            total_lines: 100,
            cyclomatic_complexity: 10,
            max_nested_depth: 3,
            control_structures: 5,
            maintainability_index: 75.0,
            average_line_length: 50,
        };

        let risk_score = VulnerabilityScannerUtils::calculate_risk_score(
            &VulnerabilitySeverity::High,
            &VulnerabilityCategory::Security,
            0.9,
            &complexity,
        );

        assert!(risk_score > 0.0);
        assert!(risk_score <= 10.0);
    }
}
