//! Type definitions for vulnerability scanner utilities
//!
//! This module contains all data structures and type definitions used
//! across the vulnerability scanner utility modules.

/// Code complexity metrics
#[derive(Debug, Clone)]
pub struct ComplexityMetrics {
    /// Total number of lines
    pub total_lines: usize,
    /// Cyclomatic complexity
    pub cyclomatic_complexity: usize,
    /// Maximum nesting depth
    pub max_nested_depth: usize,
    /// Number of control structures
    pub control_structures: usize,
    /// Maintainability index (0-100)
    pub maintainability_index: f64,
    /// Average line length
    pub average_line_length: usize,
}

/// Language detection result
#[derive(Debug, Clone, PartialEq)]
pub struct LanguageDetection {
    /// Detected language
    pub language: String,
    /// Confidence score (0.0-1.0)
    pub confidence: f64,
    /// File extension that led to detection
    pub extension: String,
}

/// Function signature extraction result
#[derive(Debug, Clone)]
pub struct FunctionSignature {
    /// The function signature
    pub signature: String,
    /// Line number where function was found
    pub line_number: usize,
    /// Function name extracted from signature
    pub name: String,
    /// Parameters extracted from signature
    pub parameters: Vec<String>,
    /// Return type if available
    pub return_type: Option<String>,
}

/// Import/dependency extraction result
#[derive(Debug, Clone)]
pub struct ImportStatement {
    /// The import statement
    pub statement: String,
    /// Line number where import was found
    pub line_number: usize,
    /// Module/package being imported
    pub module: String,
    /// Alias if any
    pub alias: Option<String>,
}

/// Pattern detection result
#[derive(Debug, Clone)]
pub struct PatternMatch {
    /// The pattern that matched
    pub pattern: String,
    /// Line number where pattern was found
    pub line_number: usize,
    /// Column number where pattern starts
    pub column_number: usize,
    /// The matched text
    pub matched_text: String,
    /// Confidence score for this match
    pub confidence: f64,
    /// Context around the match
    pub context: String,
}

/// File analysis result
#[derive(Debug, Clone)]
pub struct FileAnalysis {
    /// File path
    pub file_path: String,
    /// Detected language
    pub language: Option<String>,
    /// File size in bytes
    pub file_size: u64,
    /// Is binary file
    pub is_binary: bool,
    /// Complexity metrics
    pub complexity: Option<ComplexityMetrics>,
    /// Function signatures found
    pub functions: Vec<FunctionSignature>,
    /// Import statements found
    pub imports: Vec<ImportStatement>,
    /// Pattern matches found
    pub patterns: Vec<PatternMatch>,
    /// Analysis timestamp
    pub analyzed_at: String,
}

/// Quality assessment result
#[derive(Debug, Clone)]
pub struct QualityAssessment {
    /// Overall quality score (0.0-1.0)
    pub overall_score: f64,
    /// Maintainability score (0.0-1.0)
    pub maintainability_score: f64,
    /// Complexity score (0.0-1.0, lower is better)
    pub complexity_score: f64,
    /// Readability score (0.0-1.0)
    pub readability_score: f64,
    /// Security score (0.0-1.0)
    pub security_score: f64,
    /// Performance score (0.0-1.0)
    pub performance_score: f64,
    /// Issues found
    pub issues: Vec<QualityIssue>,
    /// Recommendations
    pub recommendations: Vec<String>,
}

/// Quality issue found during assessment
#[derive(Debug, Clone)]
pub struct QualityIssue {
    /// Issue type
    pub issue_type: QualityIssueType,
    /// Severity level
    pub severity: QualityIssueSeverity,
    /// Description of the issue
    pub description: String,
    /// Line number where issue was found
    pub line_number: Option<usize>,
    /// Suggested fix
    pub suggested_fix: String,
    /// Impact assessment
    pub impact: String,
}

/// Quality issue types
#[derive(Debug, Clone, PartialEq)]
pub enum QualityIssueType {
    /// Code complexity issue
    Complexity,
    /// Code style issue
    Style,
    /// Performance issue
    Performance,
    /// Security issue
    Security,
    /// Maintainability issue
    Maintainability,
    /// Documentation issue
    Documentation,
    /// Testing issue
    Testing,
    /// Other issue type
    Other(String),
}

/// Quality issue severity levels
#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord)]
pub enum QualityIssueSeverity {
    /// Critical issue
    Critical,
    /// High severity issue
    High,
    /// Medium severity issue
    Medium,
    /// Low severity issue
    Low,
    /// Informational issue
    Info,
}

/// Analysis configuration
#[derive(Debug, Clone)]
pub struct AnalysisConfig {
    /// Maximum file size to analyze (in bytes)
    pub max_file_size: usize,
    /// Maximum line length
    pub max_line_length: usize,
    /// Maximum cyclomatic complexity
    pub max_cyclomatic_complexity: usize,
    /// Maximum nesting depth
    pub max_nesting_depth: usize,
    /// Minimum maintainability index
    pub min_maintainability_index: f64,
    /// Languages to analyze (empty means all)
    pub languages: Vec<String>,
    /// File extensions to include (empty means all)
    pub include_extensions: Vec<String>,
    /// File extensions to exclude
    pub exclude_extensions: Vec<String>,
    /// Enable pattern detection
    pub enable_pattern_detection: bool,
    /// Enable complexity analysis
    pub enable_complexity_analysis: bool,
    /// Enable quality assessment
    pub enable_quality_assessment: bool,
}

impl Default for AnalysisConfig {
    fn default() -> Self {
        Self {
            max_file_size: 1024 * 1024, // 1MB
            max_line_length: 100,
            max_cyclomatic_complexity: 10,
            max_nesting_depth: 4,
            min_maintainability_index: 65.0,
            languages: Vec::new(),
            include_extensions: Vec::new(),
            exclude_extensions: vec!["bin".to_string(), "exe".to_string(), "dll".to_string()],
            enable_pattern_detection: true,
            enable_complexity_analysis: true,
            enable_quality_assessment: true,
        }
    }
}

/// Analysis result
#[derive(Debug, Clone)]
pub struct AnalysisResult {
    /// File path that was analyzed
    pub file_path: String,
    /// Analysis configuration used
    pub config: AnalysisConfig,
    /// File analysis result
    pub file_analysis: FileAnalysis,
    /// Quality assessment result
    pub quality_assessment: Option<QualityAssessment>,
    /// Analysis duration in milliseconds
    pub analysis_duration_ms: u64,
    /// Analysis timestamp
    pub analyzed_at: String,
    /// Analysis errors if any
    pub errors: Vec<String>,
}

impl Default for ComplexityMetrics {
    fn default() -> Self {
        Self {
            total_lines: 0,
            cyclomatic_complexity: 1,
            max_nested_depth: 0,
            control_structures: 0,
            maintainability_index: 100.0,
            average_line_length: 0,
        }
    }
}

impl Default for LanguageDetection {
    fn default() -> Self {
        Self {
            language: "unknown".to_string(),
            confidence: 0.0,
            extension: "unknown".to_string(),
        }
    }
}

impl Default for FileAnalysis {
    fn default() -> Self {
        Self {
            file_path: String::new(),
            language: None,
            file_size: 0,
            is_binary: false,
            complexity: None,
            functions: Vec::new(),
            imports: Vec::new(),
            patterns: Vec::new(),
            analyzed_at: chrono::Utc::now().to_rfc3339(),
        }
    }
}

impl Default for QualityAssessment {
    fn default() -> Self {
        Self {
            overall_score: 0.0,
            maintainability_score: 0.0,
            complexity_score: 0.0,
            readability_score: 0.0,
            security_score: 0.0,
            performance_score: 0.0,
            issues: Vec::new(),
            recommendations: Vec::new(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_complexity_metrics_default() {
        let metrics = ComplexityMetrics::default();
        assert_eq!(metrics.total_lines, 0);
        assert_eq!(metrics.cyclomatic_complexity, 1);
        assert_eq!(metrics.max_nested_depth, 0);
        assert_eq!(metrics.control_structures, 0);
        assert_eq!(metrics.maintainability_index, 100.0);
        assert_eq!(metrics.average_line_length, 0);
    }

    #[test]
    fn test_analysis_config_default() {
        let config = AnalysisConfig::default();
        assert_eq!(config.max_file_size, 1024 * 1024);
        assert_eq!(config.max_line_length, 100);
        assert_eq!(config.max_cyclomatic_complexity, 10);
        assert_eq!(config.max_nesting_depth, 4);
        assert_eq!(config.min_maintainability_index, 65.0);
        assert!(config.languages.is_empty());
        assert!(config.include_extensions.is_empty());
        assert!(!config.exclude_extensions.is_empty());
        assert!(config.enable_pattern_detection);
        assert!(config.enable_complexity_analysis);
        assert!(config.enable_quality_assessment);
    }

    #[test]
    fn test_language_detection_default() {
        let detection = LanguageDetection::default();
        assert_eq!(detection.language, "unknown");
        assert_eq!(detection.confidence, 0.0);
        assert_eq!(detection.extension, "unknown");
    }

    #[test]
    fn test_quality_issue_severity_ordering() {
        assert!(QualityIssueSeverity::Critical < QualityIssueSeverity::High);
        assert!(QualityIssueSeverity::High < QualityIssueSeverity::Medium);
        assert!(QualityIssueSeverity::Medium < QualityIssueSeverity::Low);
        assert!(QualityIssueSeverity::Low < QualityIssueSeverity::Info);
    }

    #[test]
    fn test_function_signature() {
        let signature = FunctionSignature {
            signature: "fn test() -> i32".to_string(),
            line_number: 10,
            name: "test".to_string(),
            parameters: Vec::new(),
            return_type: Some("i32".to_string()),
        };

        assert_eq!(signature.name, "test");
        assert_eq!(signature.line_number, 10);
        assert!(signature.parameters.is_empty());
        assert_eq!(signature.return_type, Some("i32".to_string()));
    }

    #[test]
    fn test_import_statement() {
        let import = ImportStatement {
            statement: "use std::collections::HashMap;".to_string(),
            line_number: 5,
            module: "std::collections::HashMap".to_string(),
            alias: None,
        };

        assert_eq!(import.line_number, 5);
        assert_eq!(import.module, "std::collections::HashMap");
        assert!(import.alias.is_none());
    }

    #[test]
    fn test_pattern_match() {
        let pattern_match = PatternMatch {
            pattern: r"panic!\(".to_string(),
            line_number: 15,
            column_number: 8,
            matched_text: "panic!(\"error\")".to_string(),
            confidence: 0.9,
            context: "    if error { panic!(\"error\"); }".to_string(),
        };

        assert_eq!(pattern_match.line_number, 15);
        assert_eq!(pattern_match.column_number, 8);
        assert_eq!(pattern_match.confidence, 0.9);
        assert!(pattern_match.context.contains("panic!"));
    }
}
