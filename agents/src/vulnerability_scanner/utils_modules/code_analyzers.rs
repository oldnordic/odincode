//! Code analysis utilities for the vulnerability scanner
//!
//! This module contains utilities for analyzing code complexity, file operations,
//! and other code analysis tasks.

use anyhow::Result;
use std::path::Path;

use super::types::{
    AnalysisConfig, ComplexityMetrics, FileAnalysis, LanguageDetection, PatternMatch, QualityIssue,
    QualityIssueSeverity, QualityIssueType,
};

// Re-export QualityAssessment from types module
pub use super::types::QualityAssessment;

#[derive(Debug, Clone, PartialEq)]
pub enum QualityGrade {
    Excellent,
    Good,
    Fair,
    Poor,
    Critical,
}

#[derive(Debug, Clone)]
pub struct CodeQualityIssue {
    pub severity: QualityIssueSeverity,
    pub message: String,
    pub suggestion: String,
}

#[derive(Debug, Clone)]
pub struct FileCharacteristics {
    pub path: std::path::PathBuf,
    pub size: u64,
    pub is_binary: bool,
    pub language: Option<String>,
    pub is_readable: bool,
    pub created: Option<std::time::SystemTime>,
    pub modified: Option<std::time::SystemTime>,
}

#[derive(Debug, Clone)]
pub struct CodePattern {
    pub pattern_type: PatternType,
    pub line_number: usize,
    pub description: String,
    pub severity: PatternSeverity,
    pub suggestion: String,
}

#[derive(Debug, Clone, PartialEq)]
pub enum PatternType {
    LongFunction,
    DeepNesting,
    MagicNumber,
    TodoComment,
    DuplicateCode,
}

#[derive(Debug, Clone, PartialEq)]
pub enum PatternSeverity {
    Error,
    Warning,
    Info,
}

/// Code complexity analysis utilities
pub struct ComplexityAnalyzer;

impl ComplexityAnalyzer {
    /// Calculate code complexity metrics
    pub fn calculate_metrics(code: &str) -> ComplexityMetrics {
        let lines: Vec<&str> = code.lines().collect();
        let total_lines = lines.len();

        let mut cyclomatic_complexity = 1; // Base complexity
        let mut nested_depth: usize = 0;
        let mut max_nested_depth: usize = 0;
        let mut control_structures = 0;

        for line in lines {
            let line = line.trim();

            // Count control structures
            if line.starts_with("if ")
                || line.starts_with("else if ")
                || line.starts_with("for ")
                || line.starts_with("while ")
                || line.starts_with("match ")
                || line.starts_with("switch ")
            {
                cyclomatic_complexity += 1;
                control_structures += 1;
            }

            // Count nested structures
            if line.contains('{') {
                nested_depth += 1;
                max_nested_depth = max_nested_depth.max(nested_depth);
            }
            if line.contains('}') {
                nested_depth = nested_depth.saturating_sub(1);
            }

            // Count logical operators
            cyclomatic_complexity += line.matches("&&").count();
            cyclomatic_complexity += line.matches("||").count();
        }

        // Calculate maintainability index (simplified)
        let avg_line_length = if total_lines > 0 {
            code.chars().count() / total_lines
        } else {
            0
        };

        let maintainability_index = if total_lines > 0 {
            let volume_factor = (total_lines as f64).log10();
            let complexity_factor = (cyclomatic_complexity as f64).log10();
            let length_factor = (avg_line_length as f64).log10();

            171.0 - 5.2 * volume_factor - 0.23 * complexity_factor - 16.2 * length_factor
        } else {
            100.0
        }
        .max(0.0)
        .min(100.0);

        ComplexityMetrics {
            total_lines,
            cyclomatic_complexity,
            max_nested_depth,
            control_structures,
            maintainability_index,
            average_line_length: avg_line_length,
        }
    }

    /// Analyze code quality based on complexity metrics
    pub fn assess_quality(metrics: &ComplexityMetrics) -> Result<QualityAssessment> {
        let mut issues = Vec::new();
        let mut score: f64 = 100.0;

        // Check cyclomatic complexity
        if metrics.cyclomatic_complexity > 10 {
            issues.push(CodeQualityIssue {
                severity: QualityIssueSeverity::Medium,
                message: format!(
                    "High cyclomatic complexity: {}",
                    metrics.cyclomatic_complexity
                ),
                suggestion:
                    "Consider refactoring complex functions into smaller, more focused functions."
                        .to_string(),
            });
            score -= (metrics.cyclomatic_complexity - 10) as f64 * 2.0;
        }

        // Check nesting depth
        if metrics.max_nested_depth > 4 {
            issues.push(CodeQualityIssue {
                severity: QualityIssueSeverity::Medium,
                message: format!("High nesting depth: {}", metrics.max_nested_depth),
                suggestion: "Consider reducing nesting depth by using early returns or extracting helper functions.".to_string(),
            });
            score -= (metrics.max_nested_depth - 4) as f64 * 3.0;
        }

        // Check maintainability index
        if metrics.maintainability_index < 50.0 {
            issues.push(CodeQualityIssue {
                severity: QualityIssueSeverity::Critical,
                message: format!(
                    "Low maintainability index: {:.1}",
                    metrics.maintainability_index
                ),
                suggestion: "Code is difficult to maintain. Consider significant refactoring."
                    .to_string(),
            });
            score -= (50.0 - metrics.maintainability_index) * 0.5;
        }

        // Check average line length
        if metrics.average_line_length > 100 {
            issues.push(CodeQualityIssue {
                severity: QualityIssueSeverity::Medium,
                message: format!("Long average line length: {}", metrics.average_line_length),
                suggestion:
                    "Consider breaking long lines into multiple lines for better readability."
                        .to_string(),
            });
            score -= (metrics.average_line_length - 100) as f64 * 0.1;
        }

        // Ensure score is within bounds
        score = score.max(0.0).min(100.0);

        Ok(QualityAssessment {
            overall_score: score / 100.0,
            maintainability_score: (100.0 - metrics.cyclomatic_complexity as f64 * 2.0).max(0.0)
                / 100.0,
            complexity_score: metrics.cyclomatic_complexity as f64 / 50.0,
            readability_score: (100.0 - metrics.average_line_length as f64 * 0.1).max(0.0) / 100.0,
            security_score: 1.0,    // Placeholder
            performance_score: 1.0, // Placeholder
            issues: issues
                .into_iter()
                .map(|issue| QualityIssue {
                    issue_type: QualityIssueType::Complexity,
                    severity: issue.severity,
                    description: issue.message,
                    line_number: None,
                    suggested_fix: issue.suggestion,
                    impact: "Affects code maintainability".to_string(),
                })
                .collect(),
            recommendations: vec!["Consider refactoring complex code".to_string()],
        })
    }

    /// Calculate quality grade based on score
    fn calculate_grade(score: f64) -> QualityGrade {
        if score >= 90.0 {
            QualityGrade::Excellent
        } else if score >= 80.0 {
            QualityGrade::Good
        } else if score >= 70.0 {
            QualityGrade::Fair
        } else if score >= 60.0 {
            QualityGrade::Poor
        } else {
            QualityGrade::Critical
        }
    }
}

/// File analysis utilities
pub struct FileAnalyzer;

impl FileAnalyzer {
    /// Analyze a file with comprehensive analysis
    pub fn analyze_file(file_path: &Path, config: &AnalysisConfig) -> Result<FileAnalysis> {
        use std::fs;

        let metadata = fs::metadata(file_path)?;
        let file_size = metadata.len();

        // Check file size limit
        if file_size > config.max_file_size as u64 {
            return Err(anyhow::anyhow!(
                "File size {} exceeds limit {}",
                file_size,
                config.max_file_size
            ));
        }

        // Check if file is binary
        let is_binary = Self::is_binary_file(file_path)?;

        let mut analysis = FileAnalysis {
            file_path: file_path.to_string_lossy().to_string(),
            language: None,
            file_size,
            is_binary,
            complexity: None,
            functions: Vec::new(),
            imports: Vec::new(),
            patterns: Vec::new(),
            analyzed_at: chrono::Utc::now().to_rfc3339(),
        };

        if !is_binary {
            // Detect language
            if let Some(lang_detection) =
                super::function_extractors::LanguageDetector::from_file_path(file_path)
            {
                let language = lang_detection.language.clone();
                analysis.language = Some(language.clone());

                // Read file content
                let content = fs::read_to_string(file_path)?;

                // Extract functions
                if config.enable_complexity_analysis {
                    analysis.functions =
                        super::function_extractors::FunctionExtractor::extract_signatures(
                            &content, &language,
                        );
                    analysis.imports = super::function_extractors::ImportExtractor::extract_imports(
                        &content, &language,
                    );

                    // Calculate complexity
                    analysis.complexity = Some(ComplexityAnalyzer::calculate_metrics(&content));
                }
            }
        }

        Ok(analysis)
    }

    /// Check if file is binary
    pub fn is_binary_file(file_path: &Path) -> Result<bool> {
        use std::fs::File;
        use std::io::Read;

        let mut file = File::open(file_path)?;
        let mut buffer = [0; 1024];
        let bytes_read = file.read(&mut buffer)?;

        // Check for null bytes (common in binary files)
        Ok(buffer.iter().take(bytes_read).any(|&b| b == 0))
    }

    /// Get file size in bytes
    pub fn get_file_size(file_path: &Path) -> Result<u64> {
        Ok(std::fs::metadata(file_path)?.len())
    }

    /// Read file with size limit
    pub fn read_file_with_limit(file_path: &Path, max_size: usize) -> Result<String> {
        let metadata = std::fs::metadata(file_path)?;
        let file_size = metadata.len() as usize;

        if file_size > max_size {
            return Err(anyhow::anyhow!(
                "File size {} exceeds limit {}",
                file_size,
                max_size
            ));
        }

        Ok(std::fs::read_to_string(file_path)?)
    }

    /// Analyze file characteristics
    pub fn analyze_characteristics(file_path: &Path) -> Result<FileCharacteristics> {
        let metadata = std::fs::metadata(file_path)?;
        let is_binary = Self::is_binary_file(file_path)?;
        let size = metadata.len();

        let language = if !is_binary {
            if let Some(lang_detection) =
                super::function_extractors::LanguageDetector::from_file_path(file_path)
            {
                Some(lang_detection.language)
            } else {
                None
            }
        } else {
            None
        };

        Ok(FileCharacteristics {
            path: file_path.to_path_buf(),
            size,
            is_binary,
            language,
            is_readable: metadata.permissions().readonly(),
            created: metadata.created().ok(),
            modified: metadata.modified().ok(),
        })
    }
}

/// Code pattern detection utilities
pub struct PatternDetector;

impl PatternDetector {
    /// Detect common code patterns and anti-patterns
    pub fn detect_patterns(code: &str, patterns: &[String]) -> Vec<PatternMatch> {
        let mut matches = Vec::new();
        let lines: Vec<&str> = code.lines().collect();

        for (line_num, line) in lines.iter().enumerate() {
            for pattern in patterns {
                if let Some(pos) = line.find(pattern) {
                    matches.push(PatternMatch {
                        pattern: pattern.clone(),
                        line_number: line_num,
                        column_number: pos,
                        matched_text: line[pos..pos + pattern.len()].to_string(),
                        confidence: 0.9,
                        context: Self::get_context(&lines, line_num, 2),
                    });
                }
            }
        }

        matches
    }

    /// Get context around a line
    fn get_context(lines: &[&str], line_num: usize, context_lines: usize) -> String {
        let start = line_num.saturating_sub(context_lines);
        let end = (line_num + context_lines + 1).min(lines.len());

        lines[start..end]
            .iter()
            .map(|s| s.to_string())
            .collect::<Vec<_>>()
            .join("\n")
    }
}

/// Quality assessment utilities
pub struct QualityAssessor;

impl QualityAssessor {
    /// Assess code quality based on file analysis
    pub fn assess_quality(
        analysis: &FileAnalysis,
        config: &AnalysisConfig,
    ) -> Result<QualityAssessment> {
        let mut issues = Vec::new();
        let mut score: f64 = 100.0;

        // Check file size
        if analysis.file_size > config.max_file_size as u64 {
            issues.push(CodeQualityIssue {
                severity: QualityIssueSeverity::Medium,
                message: format!("Large file size: {} bytes", analysis.file_size),
                suggestion: "Consider splitting large files into smaller, more focused modules."
                    .to_string(),
            });
            score -= 10.0;
        }

        // Check complexity if available
        if let Some(complexity) = &analysis.complexity {
            if complexity.cyclomatic_complexity > config.max_cyclomatic_complexity {
                issues.push(CodeQualityIssue {
                    severity: QualityIssueSeverity::Medium,
                    message: format!("High cyclomatic complexity: {}", complexity.cyclomatic_complexity),
                    suggestion: "Consider refactoring complex functions into smaller, more focused functions.".to_string(),
                });
                score -= (complexity.cyclomatic_complexity - config.max_cyclomatic_complexity)
                    as f64
                    * 2.0;
            }

            if complexity.max_nested_depth > config.max_nesting_depth {
                issues.push(CodeQualityIssue {
                    severity: QualityIssueSeverity::Medium,
                    message: format!("High nesting depth: {}", complexity.max_nested_depth),
                    suggestion: "Consider reducing nesting depth by using early returns or extracting helper functions.".to_string(),
                });
                score -= (complexity.max_nested_depth - config.max_nesting_depth) as f64 * 3.0;
            }

            if complexity.maintainability_index < config.min_maintainability_index {
                issues.push(CodeQualityIssue {
                    severity: QualityIssueSeverity::Critical,
                    message: format!(
                        "Low maintainability index: {:.1}",
                        complexity.maintainability_index
                    ),
                    suggestion: "Code is difficult to maintain. Consider significant refactoring."
                        .to_string(),
                });
                score -=
                    (config.min_maintainability_index - complexity.maintainability_index) * 0.5;
            }
        }

        // Ensure score is within bounds
        score = score.max(0.0).min(100.0);

        Ok(QualityAssessment {
            overall_score: score / 100.0,
            maintainability_score: (100.0 - score).max(0.0) / 100.0,
            complexity_score: score / 100.0,
            readability_score: (100.0 - score).max(0.0) / 100.0,
            security_score: 1.0,
            performance_score: 1.0,
            issues: issues
                .into_iter()
                .map(|issue| QualityIssue {
                    issue_type: QualityIssueType::Complexity,
                    severity: issue.severity,
                    description: issue.message,
                    line_number: None,
                    suggested_fix: issue.suggestion,
                    impact: "Affects code maintainability".to_string(),
                })
                .collect(),
            recommendations: vec!["Consider refactoring complex code".to_string()],
        })
    }

    /// Calculate quality grade based on score
    fn calculate_grade(score: f64) -> QualityGrade {
        if score >= 90.0 {
            QualityGrade::Excellent
        } else if score >= 80.0 {
            QualityGrade::Good
        } else if score >= 70.0 {
            QualityGrade::Fair
        } else if score >= 60.0 {
            QualityGrade::Poor
        } else {
            QualityGrade::Critical
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::Path;

    #[test]
    fn test_calculate_metrics() {
        let code = r#"
            fn complex_function(x: i32) -> i32 {
                if x > 0 {
                    for i in 0..x {
                        if i % 2 == 0 {
                            println!("{}", i);
                        }
                    }
                } else {
                    while x < 0 {
                        x += 1;
                    }
                }
                x
            }
        "#;

        let metrics = ComplexityAnalyzer::calculate_metrics(code);
        assert!(metrics.cyclomatic_complexity > 1);
        assert!(metrics.max_nested_depth > 0);
        assert!(metrics.control_structures > 0);
        assert!(metrics.maintainability_index > 0.0);
    }

    #[test]
    fn test_quality_assessment() {
        let code = r#"
            fn simple_function() -> i32 {
                42
            }
        "#;

        let metrics = ComplexityAnalyzer::calculate_metrics(code);
        let assessment = ComplexityAnalyzer::assess_quality(&metrics).unwrap();

        assert!(assessment.overall_score > 0.8); // Should be high quality
        assert!(assessment.issues.is_empty());
    }

    #[test]
    fn test_file_characteristics() {
        // Create a temporary test file
        use std::fs::File;
        use std::io::Write;

        let test_file = Path::new("/tmp/test_utils.rs");
        let mut file = File::create(test_file).unwrap();
        writeln!(file, "fn test() {{}}").unwrap();
        drop(file);

        let characteristics = FileAnalyzer::analyze_characteristics(test_file).unwrap();
        assert!(!characteristics.is_binary);
        assert_eq!(characteristics.language, Some("rust".to_string()));
        assert!(characteristics.size > 0);

        // Clean up
        std::fs::remove_file(test_file).unwrap();
    }

    #[test]
    fn test_pattern_detection() {
        let code = r#"
            fn main() {
                println!("Hello");
                panic!("Error");
            }
        "#;

        let patterns = vec![r"panic!\(".to_string()];
        let matches = PatternDetector::detect_patterns(code, &patterns);
        assert_eq!(matches.len(), 1);
        assert!(matches[0].matched_text.contains("panic!"));
    }
}
