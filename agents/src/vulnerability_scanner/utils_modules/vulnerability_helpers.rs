//! Vulnerability scoring and report generation utilities
//!
//! This module contains utilities for vulnerability scoring, prioritization,
//! and report generation for the AEGIS-BUGS vulnerability scanner system.

use anyhow::Result;
use chrono::Utc;
use serde_json;
use std::collections::HashMap;

use super::types::ComplexityMetrics;
use crate::vulnerability_scanner::{
    DetectionMethod, VulnerabilityCategory, VulnerabilityFinding, VulnerabilitySeverity,
};

/// Vulnerability scoring utilities
pub struct ScoringUtils;

impl ScoringUtils {
    /// Calculate risk score for a vulnerability
    pub fn calculate_risk_score(
        severity: &VulnerabilitySeverity,
        category: &VulnerabilityCategory,
        confidence: f64,
        complexity: &ComplexityMetrics,
    ) -> f64 {
        let severity_weight = Self::get_severity_weight(severity);
        let category_weight = Self::get_category_weight(category);
        let complexity_factor = Self::get_complexity_factor(complexity);

        // Base score calculation
        let base_score = severity_weight * category_weight * confidence;

        // Adjust based on code complexity
        let adjusted_score = base_score * complexity_factor;

        // Normalize to 0-10 scale
        (adjusted_score * 10.0).min(10.0)
    }

    /// Get severity weight
    fn get_severity_weight(severity: &VulnerabilitySeverity) -> f64 {
        match severity {
            VulnerabilitySeverity::Critical => 1.0,
            VulnerabilitySeverity::High => 0.8,
            VulnerabilitySeverity::Medium => 0.6,
            VulnerabilitySeverity::Low => 0.4,
            VulnerabilitySeverity::Informational => 0.2,
        }
    }

    /// Get category weight
    fn get_category_weight(category: &VulnerabilityCategory) -> f64 {
        match category {
            VulnerabilityCategory::Security => 1.0,
            VulnerabilityCategory::MemorySafety => 0.9,
            VulnerabilityCategory::Concurrency => 0.8,
            VulnerabilityCategory::InputValidation => 0.8,
            VulnerabilityCategory::Auth => 0.9,
            VulnerabilityCategory::DataHandling => 0.7,
            VulnerabilityCategory::Performance => 0.5,
            VulnerabilityCategory::CodeQuality => 0.3,
        }
    }

    /// Get complexity factor
    fn get_complexity_factor(complexity: &ComplexityMetrics) -> f64 {
        // Higher complexity increases risk
        let complexity_factor = (complexity.cyclomatic_complexity as f64 / 10.0).min(2.0);
        let nesting_factor = (complexity.max_nested_depth as f64 / 5.0).min(2.0);
        let maintainability_factor = (100.0 - complexity.maintainability_index) / 100.0;

        1.0 + complexity_factor * 0.3 + nesting_factor * 0.2 + maintainability_factor * 0.5
    }

    /// Prioritize vulnerabilities
    pub fn prioritize_vulnerabilities(findings: &mut [VulnerabilityFinding]) {
        findings.sort_by(|a, b| {
            // First by severity
            let severity_order = |s: &VulnerabilitySeverity| match s {
                VulnerabilitySeverity::Critical => 0,
                VulnerabilitySeverity::High => 1,
                VulnerabilitySeverity::Medium => 2,
                VulnerabilitySeverity::Low => 3,
                VulnerabilitySeverity::Informational => 4,
            };

            let severity_cmp = severity_order(&a.severity).cmp(&severity_order(&b.severity));

            if severity_cmp != std::cmp::Ordering::Equal {
                return severity_cmp;
            }

            // Then by confidence
            b.confidence
                .partial_cmp(&a.confidence)
                .unwrap_or(std::cmp::Ordering::Equal)
        });
    }

    /// Group vulnerabilities by category
    pub fn group_by_category(
        findings: &[VulnerabilityFinding],
    ) -> HashMap<VulnerabilityCategory, Vec<VulnerabilityFinding>> {
        let mut groups = HashMap::new();

        for finding in findings {
            groups
                .entry(finding.category.clone())
                .or_insert_with(Vec::new)
                .push(finding.clone());
        }

        groups
    }

    /// Group vulnerabilities by severity
    pub fn group_by_severity(
        findings: &[VulnerabilityFinding],
    ) -> HashMap<VulnerabilitySeverity, Vec<VulnerabilityFinding>> {
        let mut groups = HashMap::new();

        for finding in findings {
            groups
                .entry(finding.severity.clone())
                .or_insert_with(Vec::new)
                .push(finding.clone());
        }

        groups
    }
}

/// Report generation utilities
pub struct ReportUtils;

impl ReportUtils {
    /// Generate summary statistics
    pub fn generate_summary(findings: &[VulnerabilityFinding]) -> VulnerabilitySummary {
        let total_findings = findings.len();

        let mut by_severity = HashMap::new();
        let mut by_category = HashMap::new();
        let mut by_detection_method = HashMap::new();

        let mut total_confidence = 0.0;
        let mut high_confidence_count = 0;

        for finding in findings {
            // Count by severity
            *by_severity.entry(finding.severity.clone()).or_insert(0) += 1;

            // Count by category
            *by_category.entry(finding.category.clone()).or_insert(0) += 1;

            // Count by detection method
            *by_detection_method
                .entry(finding.detection_method.clone())
                .or_insert(0) += 1;

            // Confidence statistics
            total_confidence += finding.confidence;
            if finding.confidence >= 0.8 {
                high_confidence_count += 1;
            }
        }

        let average_confidence = if total_findings > 0 {
            total_confidence / total_findings as f64
        } else {
            0.0
        };

        VulnerabilitySummary {
            total_findings,
            findings_by_severity: by_severity,
            findings_by_category: by_category,
            findings_by_detection_method: by_detection_method,
            average_confidence,
            high_confidence_count,
        }
    }

    /// Generate markdown report
    pub fn generate_markdown_report(findings: &[VulnerabilityFinding], file_path: &str) -> String {
        let summary = Self::generate_summary(findings);

        let mut report = String::new();

        report.push_str(&format!("# Vulnerability Scan Report\n\n"));
        report.push_str(&format!("**File:** {}\n\n", file_path));
        report.push_str(&format!("**Scan Date:** {}\n\n", Utc::now().to_rfc3339()));

        // Summary section
        report.push_str("## Summary\n\n");
        report.push_str(&format!(
            "- **Total Findings:** {}\n",
            summary.total_findings
        ));
        report.push_str(&format!(
            "- **Average Confidence:** {:.2}\n",
            summary.average_confidence
        ));
        report.push_str(&format!(
            "- **High Confidence Findings:** {}\n\n",
            summary.high_confidence_count
        ));

        // Findings by severity
        report.push_str("### Findings by Severity\n\n");
        for (severity, count) in &summary.findings_by_severity {
            report.push_str(&format!("- **{:?}:** {}\n", severity, count));
        }
        report.push('\n');

        // Findings by category
        report.push_str("### Findings by Category\n\n");
        for (category, count) in &summary.findings_by_category {
            report.push_str(&format!("- **{:?}:** {}\n", category, count));
        }
        report.push('\n');

        // Detailed findings
        report.push_str("## Detailed Findings\n\n");

        for (i, finding) in findings.iter().enumerate() {
            report.push_str(&format!("### {}. {}\n\n", i + 1, finding.title));
            report.push_str(&format!("**Severity:** {:?}\n\n", finding.severity));
            report.push_str(&format!("**Category:** {:?}\n\n", finding.category));
            report.push_str(&format!("**Confidence:** {:.2}\n\n", finding.confidence));
            report.push_str(&format!("**Line:** {}\n\n", finding.line_number + 1));
            report.push_str(&format!(
                "**Detection Method:** {:?}\n\n",
                finding.detection_method
            ));

            if let Some(cwe_id) = &finding.cwe_id {
                report.push_str(&format!("**CWE ID:** {}\n\n", cwe_id));
            }

            report.push_str("**Description:**\n");
            report.push_str(&format!("{}\n\n", finding.description));

            report.push_str("**Code:**\n");
            report.push_str("```rust\n");
            report.push_str(&format!("{}\n", finding.code_snippet));
            report.push_str("```\n\n");

            report.push_str("**Suggested Fix:**\n");
            report.push_str(&format!("{}\n\n", finding.suggested_fix));

            if !finding.metadata.is_empty() {
                report.push_str("**Additional Information:**\n");
                for (key, value) in &finding.metadata {
                    report.push_str(&format!("- {}: {}\n", key, value));
                }
                report.push('\n');
            }

            report.push_str("---\n\n");
        }

        report
    }

    /// Generate JSON report
    pub fn generate_json_report(
        findings: &[VulnerabilityFinding],
        file_path: &str,
    ) -> Result<String> {
        let summary = Self::generate_summary(findings);

        let report = serde_json::json!({
            "scan_info": {
                "file_path": file_path,
                "scan_date": Utc::now().to_rfc3339(),
                "scanner_version": "1.0.0"
            },
            "summary": {
                "total_findings": summary.total_findings,
                "average_confidence": summary.average_confidence,
                "high_confidence_count": summary.high_confidence_count,
                "findings_by_severity": summary.findings_by_severity,
                "findings_by_category": summary.findings_by_category,
                "findings_by_detection_method": summary.findings_by_detection_method
            },
            "findings": findings
        });

        Ok(serde_json::to_string_pretty(&report)?)
    }
}

/// Vulnerability summary statistics
#[derive(Debug, Clone)]
pub struct VulnerabilitySummary {
    /// Total number of findings
    pub total_findings: usize,
    /// Findings grouped by severity
    pub findings_by_severity: HashMap<VulnerabilitySeverity, usize>,
    /// Findings grouped by category
    pub findings_by_category: HashMap<VulnerabilityCategory, usize>,
    /// Findings grouped by detection method
    pub findings_by_detection_method: HashMap<DetectionMethod, usize>,
    /// Average confidence score
    pub average_confidence: f64,
    /// Number of high confidence findings
    pub high_confidence_count: usize,
}

#[cfg(test)]
mod tests {
    use super::*;
    use uuid::Uuid;

    #[test]
    fn test_scoring_utils() {
        let complexity = ComplexityMetrics {
            total_lines: 100,
            cyclomatic_complexity: 10,
            max_nested_depth: 3,
            control_structures: 5,
            maintainability_index: 75.0,
            average_line_length: 50,
        };

        let risk_score = ScoringUtils::calculate_risk_score(
            &VulnerabilitySeverity::High,
            &VulnerabilityCategory::Security,
            0.9,
            &complexity,
        );

        assert!(risk_score > 0.0);
        assert!(risk_score <= 10.0);
    }

    #[test]
    fn test_report_generation() {
        let finding = VulnerabilityFinding {
            id: Uuid::new_v4(),
            file_path: "test.rs".to_string(),
            line_number: 10,
            column_number: 5,
            severity: VulnerabilitySeverity::High,
            category: VulnerabilityCategory::Security,
            title: "Test vulnerability".to_string(),
            description: "Test description".to_string(),
            code_snippet: "let x = 5;".to_string(),
            suggested_fix: "Fix it".to_string(),
            confidence: 0.9,
            detection_method: DetectionMethod::PatternBased,
            cwe_id: Some("CWE-123".to_string()),
            metadata: HashMap::new(),
        };

        let findings = vec![finding];
        let summary = ReportUtils::generate_summary(&findings);

        assert_eq!(summary.total_findings, 1);
        assert_eq!(summary.average_confidence, 0.9);
        assert_eq!(summary.high_confidence_count, 1);

        let markdown_report = ReportUtils::generate_markdown_report(&findings, "test.rs");
        assert!(markdown_report.contains("Test vulnerability"));
        assert!(markdown_report.contains("High"));
        assert!(markdown_report.contains("Security"));

        let json_report = ReportUtils::generate_json_report(&findings, "test.rs").unwrap();
        assert!(json_report.contains("test.rs"));
        assert!(json_report.contains("Test vulnerability"));
    }

    #[test]
    fn test_prioritize_vulnerabilities() {
        let mut findings = vec![
            VulnerabilityFinding {
                id: Uuid::new_v4(),
                file_path: "test.rs".to_string(),
                line_number: 10,
                column_number: 5,
                severity: VulnerabilitySeverity::Low,
                category: VulnerabilityCategory::CodeQuality,
                title: "Low severity".to_string(),
                description: "Low severity issue".to_string(),
                code_snippet: "let x = 5;".to_string(),
                suggested_fix: "Fix it".to_string(),
                confidence: 0.9,
                detection_method: DetectionMethod::PatternBased,
                cwe_id: None,
                metadata: HashMap::new(),
            },
            VulnerabilityFinding {
                id: Uuid::new_v4(),
                file_path: "test.rs".to_string(),
                line_number: 20,
                column_number: 5,
                severity: VulnerabilitySeverity::High,
                category: VulnerabilityCategory::Security,
                title: "High severity".to_string(),
                description: "High severity issue".to_string(),
                code_snippet: "let y = 10;".to_string(),
                suggested_fix: "Fix it now".to_string(),
                confidence: 0.8,
                detection_method: DetectionMethod::PatternBased,
                cwe_id: None,
                metadata: HashMap::new(),
            },
        ];

        ScoringUtils::prioritize_vulnerabilities(&mut findings);

        // High severity should come first
        assert_eq!(findings[0].severity, VulnerabilitySeverity::High);
        assert_eq!(findings[1].severity, VulnerabilitySeverity::Low);
    }

    #[test]
    fn test_group_by_category() {
        let findings = vec![
            VulnerabilityFinding {
                id: Uuid::new_v4(),
                file_path: "test.rs".to_string(),
                line_number: 10,
                column_number: 5,
                severity: VulnerabilitySeverity::High,
                category: VulnerabilityCategory::Security,
                title: "Security issue".to_string(),
                description: "Security issue".to_string(),
                code_snippet: "let x = 5;".to_string(),
                suggested_fix: "Fix it".to_string(),
                confidence: 0.9,
                detection_method: DetectionMethod::PatternBased,
                cwe_id: None,
                metadata: HashMap::new(),
            },
            VulnerabilityFinding {
                id: Uuid::new_v4(),
                file_path: "test.rs".to_string(),
                line_number: 20,
                column_number: 5,
                severity: VulnerabilitySeverity::Medium,
                category: VulnerabilityCategory::CodeQuality,
                title: "Code quality issue".to_string(),
                description: "Code quality issue".to_string(),
                code_snippet: "let y = 10;".to_string(),
                suggested_fix: "Improve it".to_string(),
                confidence: 0.7,
                detection_method: DetectionMethod::PatternBased,
                cwe_id: None,
                metadata: HashMap::new(),
            },
        ];

        let groups = ScoringUtils::group_by_category(&findings);

        assert_eq!(groups.len(), 2);
        assert!(groups.contains_key(&VulnerabilityCategory::Security));
        assert!(groups.contains_key(&VulnerabilityCategory::CodeQuality));
        assert_eq!(groups[&VulnerabilityCategory::Security].len(), 1);
        assert_eq!(groups[&VulnerabilityCategory::CodeQuality].len(), 1);
    }
}
