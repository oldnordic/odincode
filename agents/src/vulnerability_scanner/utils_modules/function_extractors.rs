//! Function extraction utilities for the vulnerability scanner
//!
//! This module contains utilities for extracting function signatures and imports
//! from various programming languages.

use anyhow::Result;
use std::path::Path;

use super::types::{FunctionSignature, ImportStatement, LanguageDetection};

/// Function signature extraction utilities
pub struct FunctionExtractor;

impl FunctionExtractor {
    /// Extract function signatures from code
    pub fn extract_signatures(code: &str, language: &str) -> Vec<FunctionSignature> {
        match language.to_lowercase().as_str() {
            "rust" => Self::extract_rust_signatures(code),
            "python" => Self::extract_python_signatures(code),
            "javascript" | "typescript" => Self::extract_js_signatures(code),
            "go" => Self::extract_go_signatures(code),
            _ => Vec::new(),
        }
    }

    /// Extract Rust function signatures
    fn extract_rust_signatures(code: &str) -> Vec<FunctionSignature> {
        let mut functions = Vec::new();
        let lines: Vec<&str> = code.lines().collect();

        for (i, line) in lines.iter().enumerate() {
            let line = line.trim();
            if line.starts_with("fn ")
                || line.starts_with("pub fn ")
                || line.starts_with("async fn ")
            {
                // Extract function signature
                let signature = line.split('{').next().unwrap_or(line).trim();
                if !signature.is_empty() {
                    functions.push(FunctionSignature {
                        signature: signature.to_string(),
                        line_number: i,
                        name: Self::extract_function_name(signature),
                        parameters: Self::extract_parameters(signature),
                        return_type: Self::extract_return_type(signature),
                    });
                }
            }
        }

        functions
    }

    /// Extract Python function signatures
    fn extract_python_signatures(code: &str) -> Vec<FunctionSignature> {
        let mut functions = Vec::new();
        let lines: Vec<&str> = code.lines().collect();

        for (i, line) in lines.iter().enumerate() {
            let line = line.trim();
            if line.starts_with("def ") {
                // Extract function signature
                let signature = line.split(':').next().unwrap_or(line).trim();
                if !signature.is_empty() {
                    functions.push(FunctionSignature {
                        signature: signature.to_string(),
                        line_number: i,
                        name: Self::extract_function_name(signature),
                        parameters: Self::extract_parameters(signature),
                        return_type: None, // Python doesn't have explicit return types in signature
                    });
                }
            }
        }

        functions
    }

    /// Extract JavaScript/TypeScript function signatures
    fn extract_js_signatures(code: &str) -> Vec<FunctionSignature> {
        let mut functions = Vec::new();
        let lines: Vec<&str> = code.lines().collect();

        for (i, line) in lines.iter().enumerate() {
            let line = line.trim();
            if line.starts_with("function ")
                || line.starts_with("async function ")
                || line.contains("=>")
                || line.starts_with("const ")
                || line.starts_with("let ")
            {
                // Extract function signature (simplified)
                if line.contains("function") {
                    let signature = line.split('{').next().unwrap_or(line).trim();
                    if !signature.is_empty() {
                        functions.push(FunctionSignature {
                            signature: signature.to_string(),
                            line_number: i,
                            name: Self::extract_function_name(signature),
                            parameters: Self::extract_parameters(signature),
                            return_type: None,
                        });
                    }
                } else if line.contains("=>") {
                    let signature = line.split("=>").next().unwrap_or(line).trim();
                    if !signature.is_empty() {
                        functions.push(FunctionSignature {
                            signature: format!("{} =>", signature),
                            line_number: i,
                            name: Self::extract_function_name(signature),
                            parameters: Self::extract_parameters(signature),
                            return_type: None,
                        });
                    }
                }
            }
        }

        functions
    }

    /// Extract Go function signatures
    fn extract_go_signatures(code: &str) -> Vec<FunctionSignature> {
        let mut functions = Vec::new();
        let lines: Vec<&str> = code.lines().collect();

        for (i, line) in lines.iter().enumerate() {
            let line = line.trim();
            if line.starts_with("func ") {
                // Extract function signature
                let signature = line.split('{').next().unwrap_or(line).trim();
                if !signature.is_empty() {
                    functions.push(FunctionSignature {
                        signature: signature.to_string(),
                        line_number: i,
                        name: Self::extract_function_name(signature),
                        parameters: Self::extract_parameters(signature),
                        return_type: Self::extract_return_type(signature),
                    });
                }
            }
        }

        functions
    }

    /// Extract function name from signature
    fn extract_function_name(signature: &str) -> String {
        let parts: Vec<&str> = signature.split_whitespace().collect();
        for (i, part) in parts.iter().enumerate() {
            if part.starts_with("fn")
                || part.starts_with("def")
                || part.starts_with("function")
                || part.starts_with("func")
            {
                if let Some(next_part) = parts.get(i + 1) {
                    return next_part.split('(').next().unwrap_or(next_part).to_string();
                }
            } else if part.contains("=>") {
                // Arrow function
                if let Some(prev_part) = parts.get(i.saturating_sub(1)) {
                    if *prev_part == "const" || *prev_part == "let" {
                        if let Some(next_part) = parts.get(i + 1) {
                            return next_part.split('=').next().unwrap_or(next_part).to_string();
                        }
                    }
                }
                return part
                    .split('=')
                    .next()
                    .unwrap_or(part)
                    .split('(')
                    .next()
                    .unwrap_or(part)
                    .to_string();
            }
        }
        "unknown".to_string()
    }

    /// Extract parameters from signature
    fn extract_parameters(signature: &str) -> Vec<String> {
        if let Some(start) = signature.find('(') {
            if let Some(end) = signature.find(')') {
                let params_str = &signature[start + 1..end];
                if params_str.is_empty() {
                    return Vec::new();
                }
                return params_str
                    .split(',')
                    .map(|s| s.trim().to_string())
                    .filter(|s| !s.is_empty())
                    .collect();
            }
        }
        Vec::new()
    }

    /// Extract return type from signature
    fn extract_return_type(signature: &str) -> Option<String> {
        if let Some(arrow_pos) = signature.find("->") {
            let return_part = &signature[arrow_pos + 2..];
            let return_type = return_part.split('{').next().unwrap_or(return_part).trim();
            if !return_type.is_empty() {
                return Some(return_type.to_string());
            }
        }
        None
    }
}

/// Import extraction utilities
pub struct ImportExtractor;

impl ImportExtractor {
    /// Extract imports and dependencies from code
    pub fn extract_imports(code: &str, language: &str) -> Vec<ImportStatement> {
        match language.to_lowercase().as_str() {
            "rust" => Self::extract_rust_imports(code),
            "python" => Self::extract_python_imports(code),
            "javascript" | "typescript" => Self::extract_js_imports(code),
            "go" => Self::extract_go_imports(code),
            _ => Vec::new(),
        }
    }

    /// Extract Rust imports
    fn extract_rust_imports(code: &str) -> Vec<ImportStatement> {
        let mut imports = Vec::new();
        let lines: Vec<&str> = code.lines().collect();

        for (i, line) in lines.iter().enumerate() {
            let line = line.trim();
            if line.starts_with("use ") {
                let import = line.trim_start_matches("use ").trim_end_matches(';').trim();
                if !import.is_empty() {
                    imports.push(ImportStatement {
                        statement: line.to_string(),
                        line_number: i,
                        module: import.to_string(),
                        alias: Self::extract_alias(import),
                    });
                }
            }
        }

        imports
    }

    /// Extract Python imports
    fn extract_python_imports(code: &str) -> Vec<ImportStatement> {
        let mut imports = Vec::new();
        let lines: Vec<&str> = code.lines().collect();

        for (i, line) in lines.iter().enumerate() {
            let line = line.trim();
            if line.starts_with("import ") || line.starts_with("from ") {
                imports.push(ImportStatement {
                    statement: line.to_string(),
                    line_number: i,
                    module: Self::extract_python_module(line),
                    alias: Self::extract_alias(line),
                });
            }
        }

        imports
    }

    /// Extract JavaScript/TypeScript imports
    fn extract_js_imports(code: &str) -> Vec<ImportStatement> {
        let mut imports = Vec::new();
        let lines: Vec<&str> = code.lines().collect();

        for (i, line) in lines.iter().enumerate() {
            let line = line.trim();
            if line.starts_with("import ") || line.starts_with("require(") {
                imports.push(ImportStatement {
                    statement: line.to_string(),
                    line_number: i,
                    module: Self::extract_js_module(line),
                    alias: Self::extract_alias(line),
                });
            }
        }

        imports
    }

    /// Extract Go imports
    fn extract_go_imports(code: &str) -> Vec<ImportStatement> {
        let mut imports = Vec::new();
        let lines: Vec<&str> = code.lines().collect();

        for (i, line) in lines.iter().enumerate() {
            let line = line.trim();
            if line.starts_with("import ") || (line.starts_with("\"") && line.ends_with("\"")) {
                imports.push(ImportStatement {
                    statement: line.to_string(),
                    line_number: i,
                    module: Self::extract_go_module(line),
                    alias: None,
                });
            }
        }

        imports
    }

    /// Extract alias from import statement
    fn extract_alias(import: &str) -> Option<String> {
        if let Some(as_pos) = import.find(" as ") {
            let alias_part = &import[as_pos + 4..];
            let alias = alias_part.split_whitespace().next().unwrap_or(alias_part);
            if !alias.is_empty() {
                return Some(alias.to_string());
            }
        }
        None
    }

    /// Extract Python module from import statement
    fn extract_python_module(import: &str) -> String {
        if import.starts_with("from ") {
            if let Some(import_pos) = import.find(" import ") {
                return import[4..import_pos].trim().to_string();
            }
        } else if import.starts_with("import ") {
            let module_part = import[6..].trim();
            return module_part
                .split(',')
                .next()
                .unwrap_or(module_part)
                .trim()
                .to_string();
        }
        import.to_string()
    }

    /// Extract JavaScript module from import statement
    fn extract_js_module(import: &str) -> String {
        if import.starts_with("import ") {
            if let Some(from_pos) = import.find(" from ") {
                let module_part = &import[from_pos + 6..];
                return module_part
                    .trim_matches('"')
                    .trim_matches('\'')
                    .trim_matches(';')
                    .to_string();
            }
        } else if import.starts_with("require(") {
            let module_part = import[8..]
                .trim_matches(')')
                .trim_matches('"')
                .trim_matches('\'');
            return module_part.to_string();
        }
        import.to_string()
    }

    /// Extract Go module from import statement
    fn extract_go_module(import: &str) -> String {
        if import.starts_with("import ") {
            let module_part = import[6..].trim();
            return module_part.trim_matches('"').to_string();
        } else if import.starts_with("\"") && import.ends_with("\"") {
            return import.trim_matches('"').to_string();
        }
        import.to_string()
    }
}

/// Language detection utilities
pub struct LanguageDetector;

impl LanguageDetector {
    /// Determine programming language from file extension
    pub fn from_file_path(file_path: &Path) -> Option<LanguageDetection> {
        let extension = Self::get_file_extension(file_path)?;
        let (language, confidence) = Self::language_from_extension(&extension);

        Some(LanguageDetection {
            language,
            confidence,
            extension,
        })
    }

    /// Get file extension
    fn get_file_extension(file_path: &Path) -> Option<String> {
        file_path
            .extension()
            .and_then(|ext| ext.to_str())
            .map(|s| s.to_lowercase())
    }

    /// Language detection from extension with confidence
    fn language_from_extension(extension: &str) -> (String, f64) {
        match extension {
            "rs" => ("rust".to_string(), 1.0),
            "py" => ("python".to_string(), 1.0),
            "js" => ("javascript".to_string(), 0.9),
            "ts" => ("typescript".to_string(), 1.0),
            "go" => ("go".to_string(), 1.0),
            "c" => ("c".to_string(), 0.9),
            "cpp" | "cc" | "cxx" => ("cpp".to_string(), 0.9),
            "h" | "hpp" => ("cpp".to_string(), 0.7), // Could be C or C++
            "java" => ("java".to_string(), 1.0),
            "rb" => ("ruby".to_string(), 0.9),
            "php" => ("php".to_string(), 0.9),
            "swift" => ("swift".to_string(), 1.0),
            "kt" => ("kotlin".to_string(), 1.0),
            "scala" => ("scala".to_string(), 1.0),
            "sh" => ("shell".to_string(), 0.8),
            "sql" => ("sql".to_string(), 0.9),
            "html" => ("html".to_string(), 0.9),
            "css" => ("css".to_string(), 0.9),
            "json" => ("json".to_string(), 1.0),
            "xml" => ("xml".to_string(), 0.9),
            "yaml" | "yml" => ("yaml".to_string(), 0.9),
            "toml" => ("toml".to_string(), 1.0),
            "md" => ("markdown".to_string(), 0.8),
            _ => ("unknown".to_string(), 0.0),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::Path;

    #[test]
    fn test_extract_signatures() {
        let rust_code = r#"
            fn main() {
                println!("Hello, world!");
            }
            
            pub fn add(a: i32, b: i32) -> i32 {
                a + b
            }
            
            async fn fetch_data() -> Result<String, Error> {
                Ok("data".to_string())
            }
        "#;

        let signatures = FunctionExtractor::extract_signatures(rust_code, "rust");
        assert_eq!(signatures.len(), 3);
        assert!(signatures[0].signature.contains("fn main()"));
        assert!(signatures[1].signature.contains("pub fn add"));
        assert!(signatures[2].signature.contains("async fn fetch_data"));
    }

    #[test]
    fn test_extract_imports() {
        let rust_code = r#"
            use std::collections::HashMap;
            use std::fs::File;
            use serde::{Deserialize, Serialize};
        "#;

        let imports = ImportExtractor::extract_imports(rust_code, "rust");
        assert_eq!(imports.len(), 3);
        assert!(imports[0].module.contains("std::collections::HashMap"));
    }

    #[test]
    fn test_from_file_path() {
        let detection = LanguageDetector::from_file_path(Path::new("test.rs")).unwrap();
        assert_eq!(detection.language, "rust");
        assert_eq!(detection.confidence, 1.0);
        assert_eq!(detection.extension, "rs");
    }

    #[test]
    fn test_python_function_extraction() {
        let python_code = r#"
            def main():
                print("Hello, world!")
            
            def add(a, b):
                return a + b
            
            async def fetch_data():
                return "data"
        "#;

        let signatures = FunctionExtractor::extract_signatures(python_code, "python");
        assert_eq!(signatures.len(), 3);
        assert!(signatures[0].signature.contains("def main"));
        assert!(signatures[1].signature.contains("def add"));
        assert!(signatures[2].signature.contains("async def fetch_data"));
    }

    #[test]
    fn test_javascript_function_extraction() {
        let js_code = r#"
            function main() {
                console.log("Hello, world!");
            }
            
            const add = (a, b) => a + b;
            
            async function fetch_data() {
                return "data";
            }
        "#;

        let signatures = FunctionExtractor::extract_signatures(js_code, "javascript");
        assert_eq!(signatures.len(), 3);
        assert!(signatures[0].signature.contains("function main"));
        assert!(signatures[1].signature.contains("=>"));
        assert!(signatures[2]
            .signature
            .contains("async function fetch_data"));
    }

    #[test]
    fn test_go_function_extraction() {
        let go_code = r#"
            func main() {
                fmt.Println("Hello, world!")
            }
            
            func add(a int, b int) int {
                return a + b
            }
        "#;

        let signatures = FunctionExtractor::extract_signatures(go_code, "go");
        assert_eq!(signatures.len(), 2);
        assert!(signatures[0].signature.contains("func main"));
        assert!(signatures[1].signature.contains("func add"));
    }
}
