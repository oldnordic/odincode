pub mod feature_extractor;
pub mod gnn_inference;
pub mod graph_builder;
pub mod pattern_matcher;
pub mod types;

use crate::vulnerability_scanner::semantic_analyzer::feature_extractor::FeatureExtractorImpl;
use crate::vulnerability_scanner::semantic_analyzer::gnn_inference::GNNInferenceEngine;
use crate::vulnerability_scanner::semantic_analyzer::graph_builder::GraphBuilder;
use crate::vulnerability_scanner::semantic_analyzer::pattern_matcher::PatternMatcher;
use crate::vulnerability_scanner::semantic_analyzer::types::*;
use anyhow::Result;
use std::time::Instant;
use uuid::Uuid;

/// Convert semantic analyzer Vulnerability to scanner VulnerabilityFinding
impl From<Vulnerability> for crate::vulnerability_scanner::VulnerabilityFinding {
    fn from(vuln: Vulnerability) -> Self {
        use crate::vulnerability_scanner::{
            DetectionMethod, VulnerabilityCategory as ScannerCategory, VulnerabilityFinding,
            VulnerabilitySeverity as ScannerSeverity,
        };

        // Map severity from semantic analyzer to scanner
        let severity = match vuln.severity {
            VulnerabilitySeverity::Low => ScannerSeverity::Low,
            VulnerabilitySeverity::Medium => ScannerSeverity::Medium,
            VulnerabilitySeverity::High => ScannerSeverity::High,
            VulnerabilitySeverity::Critical => ScannerSeverity::Critical,
        };

        // Map category from semantic analyzer to scanner
        let category = match vuln.category {
            VulnerabilityCategory::MemorySafety => ScannerCategory::MemorySafety,
            VulnerabilityCategory::Injection => ScannerCategory::Security,
            VulnerabilityCategory::Concurrency => ScannerCategory::Concurrency,
            VulnerabilityCategory::Cryptography => ScannerCategory::Security,
            VulnerabilityCategory::InputValidation => ScannerCategory::InputValidation,
            VulnerabilityCategory::Authentication => ScannerCategory::Auth,
            VulnerabilityCategory::Authorization => ScannerCategory::Auth,
            VulnerabilityCategory::Configuration => ScannerCategory::Security,
            VulnerabilityCategory::Other => ScannerCategory::CodeQuality,
        };

        VulnerabilityFinding {
            id: Uuid::new_v4(), // Generate new UUID for the finding
            file_path: vuln.location.file_path,
            line_number: vuln.location.line_number,
            column_number: vuln.location.column_number.unwrap_or(0),
            severity,
            category,
            title: vuln.pattern_name.clone(),
            description: vuln.description,
            code_snippet: vuln.location.code_snippet,
            suggested_fix: vuln.suggested_fix,
            confidence: vuln.confidence as f64,
            detection_method: DetectionMethod::SemanticAnalysis,
            cwe_id: vuln.cwe_id,
            metadata: std::collections::HashMap::new(),
        }
    }
}

/// Main semantic analyzer for vulnerability detection
pub struct SemanticAnalyzer {
    pub gnn_layers: Vec<GNNLayer>,
    pub vulnerability_patterns: std::collections::HashMap<String, VulnerabilityPattern>,
    pub feature_extractor: FeatureExtractor,
    pub gnn_engine: GNNInferenceEngine,
    pub pattern_matcher: PatternMatcher,
}

impl SemanticAnalyzer {
    /// Create a new semantic analyzer
    pub fn new(config: &crate::vulnerability_scanner::VulnerabilityScannerConfig) -> Result<Self> {
        // Initialize GNN layers
        let gnn_layers = vec![
            GNNLayer::new(64, 128, "relu".to_string()),
            GNNLayer::new(128, 64, "relu".to_string()),
            GNNLayer::new(64, 32, "relu".to_string()),
            GNNLayer::new(32, 1, "sigmoid".to_string()),
        ];

        // Initialize vulnerability patterns
        let vulnerability_patterns = Self::load_vulnerability_patterns()?;

        // Initialize feature extractor
        let feature_extractor = FeatureExtractor::new()?;

        // Initialize GNN engine
        let gnn_engine = GNNInferenceEngine::new(64, &[128, 64, 32], 1)?;

        // Initialize pattern matcher
        let pattern_matcher = PatternMatcher::new()?;

        Ok(Self {
            gnn_layers,
            vulnerability_patterns,
            feature_extractor,
            gnn_engine,
            pattern_matcher,
        })
    }

    /// Analyze code for vulnerabilities
    pub fn analyze(
        &self,
        code: &str,
        file_path: &str,
        language: &str,
    ) -> Result<SemanticAnalysisResult> {
        let start_time = Instant::now();

        // Build code graph
        let mut graph = GraphBuilder::build_graph(code, file_path)?;

        // Extract features for each node
        for node in graph.nodes.values_mut() {
            let features = FeatureExtractorImpl::extract_node_features(node, language)?;
            node.features = features;
        }

        // Extract GNN features
        let gnn_features = FeatureExtractorImpl::extract_gnn_features(&graph)?;

        // Run GNN inference
        let vulnerability_scores = self
            .gnn_engine
            .predict_vulnerabilities(&graph, &gnn_features)?;

        // Match vulnerability patterns
        let vulnerabilities = self
            .pattern_matcher
            .match_patterns(&graph, &vulnerability_scores)?;

        let analysis_time = start_time.elapsed();

        Ok(SemanticAnalysisResult {
            vulnerabilities,
            graph,
            analysis_time,
        })
    }

    /// Load vulnerability patterns
    fn load_vulnerability_patterns(
    ) -> Result<std::collections::HashMap<String, VulnerabilityPattern>> {
        let mut patterns = std::collections::HashMap::new();

        // Buffer overflow pattern
        patterns.insert(
            "buffer_overflow".to_string(),
            VulnerabilityPattern {
                name: "buffer_overflow".to_string(),
                description: "Potential buffer overflow vulnerability detected".to_string(),
                category: VulnerabilityCategory::MemorySafety,
                severity: VulnerabilitySeverity::Critical,
                node_patterns: vec![NodePattern {
                    node_type: "array_access".to_string(),
                    code_patterns: vec![
                        "arr[i]".to_string(),
                        "arr[i] =".to_string(),
                        "arr[i] +=".to_string(),
                    ],
                    feature_requirements: {
                        let mut req = std::collections::HashMap::new();
                        req.insert("index_is_dynamic".to_string(), 1.0);
                        req
                    },
                }],
                edge_patterns: vec![EdgePattern {
                    from_type: "user_input".to_string(),
                    to_type: "array_access".to_string(),
                    edge_type: "data_flow".to_string(),
                    required: true,
                }],
                constraints: vec![GraphConstraint::PathExists {
                    from_type: "user_input".to_string(),
                    to_type: "array_access".to_string(),
                    edge_type: "data_flow".to_string(),
                }],
                feature_constraints: vec![FeatureConstraint {
                    feature_name: "index_is_dynamic".to_string(),
                    min_value: Some(0.8),
                    max_value: None,
                    expected_value: None,
                }],
            },
        );

        // SQL injection pattern
        patterns.insert(
            "sql_injection".to_string(),
            VulnerabilityPattern {
                name: "sql_injection".to_string(),
                description: "Potential SQL injection vulnerability detected".to_string(),
                category: VulnerabilityCategory::Injection,
                severity: VulnerabilitySeverity::Critical,
                node_patterns: vec![NodePattern {
                    node_type: "sql_query".to_string(),
                    code_patterns: vec![
                        "SELECT * FROM".to_string(),
                        "INSERT INTO".to_string(),
                        "UPDATE".to_string(),
                        "DELETE FROM".to_string(),
                    ],
                    feature_requirements: {
                        let mut req = std::collections::HashMap::new();
                        req.insert("contains_user_input".to_string(), 1.0);
                        req
                    },
                }],
                edge_patterns: vec![EdgePattern {
                    from_type: "user_input".to_string(),
                    to_type: "sql_query".to_string(),
                    edge_type: "data_flow".to_string(),
                    required: true,
                }],
                constraints: vec![GraphConstraint::PathExists {
                    from_type: "user_input".to_string(),
                    to_type: "sql_query".to_string(),
                    edge_type: "data_flow".to_string(),
                }],
                feature_constraints: vec![FeatureConstraint {
                    feature_name: "contains_user_input".to_string(),
                    min_value: Some(0.8),
                    max_value: None,
                    expected_value: None,
                }],
            },
        );

        // Race condition pattern
        patterns.insert(
            "race_condition".to_string(),
            VulnerabilityPattern {
                name: "race_condition".to_string(),
                description: "Potential race condition vulnerability detected".to_string(),
                category: VulnerabilityCategory::Concurrency,
                severity: VulnerabilitySeverity::High,
                node_patterns: vec![NodePattern {
                    node_type: "concurrency".to_string(),
                    code_patterns: vec![
                        "thread::spawn".to_string(),
                        "std::thread".to_string(),
                        "async".to_string(),
                        "await".to_string(),
                    ],
                    feature_requirements: {
                        let mut req = std::collections::HashMap::new();
                        req.insert("is_unprotected".to_string(), 1.0);
                        req
                    },
                }],
                edge_patterns: vec![EdgePattern {
                    from_type: "concurrency".to_string(),
                    to_type: "array_access".to_string(),
                    edge_type: "data_flow".to_string(),
                    required: false,
                }],
                constraints: vec![GraphConstraint::NoCycle {
                    node_type: "concurrency".to_string(),
                }],
                feature_constraints: vec![FeatureConstraint {
                    feature_name: "is_unprotected".to_string(),
                    min_value: Some(0.8),
                    max_value: None,
                    expected_value: None,
                }],
            },
        );

        Ok(patterns)
    }

    /// Get vulnerability patterns
    pub fn get_vulnerability_patterns(
        &self,
    ) -> &std::collections::HashMap<String, VulnerabilityPattern> {
        &self.vulnerability_patterns
    }

    /// Add a custom vulnerability pattern
    pub fn add_vulnerability_pattern(&mut self, pattern: VulnerabilityPattern) {
        self.vulnerability_patterns
            .insert(pattern.name.clone(), pattern);
    }

    /// Remove a vulnerability pattern
    pub fn remove_vulnerability_pattern(&mut self, pattern_name: &str) {
        self.vulnerability_patterns.remove(pattern_name);
    }

    /// Train the GNN model
    pub fn train_gnn(
        &mut self,
        training_data: &Vec<(CodeGraph, Vec<Vec<f32>>, Vec<Vec<f32>>)>,
    ) -> Result<()> {
        self.gnn_engine.train(training_data)
    }

    /// Save the GNN model
    pub fn save_gnn_model(&self, path: &str) -> Result<()> {
        self.gnn_engine.save_weights(path)
    }

    /// Load the GNN model
    pub fn load_gnn_model(&mut self, path: &str) -> Result<()> {
        self.gnn_engine.load_weights(path)
    }

    /// Get GNN layer information
    pub fn get_gnn_info(&self) -> Vec<(usize, usize, String)> {
        self.gnn_engine.get_layer_info()
    }

    /// Extract features from code
    pub fn extract_features(&self, code: &str, language: &str) -> Result<Vec<f32>> {
        self.feature_extractor.extract_features(code, language)
    }

    /// Build a code graph
    pub fn build_code_graph(&self, code: &str, file_path: &str) -> Result<CodeGraph> {
        GraphBuilder::build_graph(code, file_path)
    }

    /// Get pattern matcher
    pub fn get_pattern_matcher(&self) -> &PatternMatcher {
        &self.pattern_matcher
    }

    /// Get mutable pattern matcher
    pub fn get_pattern_matcher_mut(&mut self) -> &mut PatternMatcher {
        &mut self.pattern_matcher
    }
}

impl FeatureExtractor {
    /// Create a new feature extractor
    pub fn new() -> Result<Self> {
        let mut language_extractors = std::collections::HashMap::new();

        // Rust feature extractor
        language_extractors.insert(
            "rust".to_string(),
            LanguageFeatureExtractor {
                language: "rust".to_string(),
                feature_types: vec![
                    "has_unsafe".to_string(),
                    "has_raw_pointers".to_string(),
                    "has_static_mut".to_string(),
                    "has_unchecked".to_string(),
                    "has_transmute".to_string(),
                ],
                extractors: {
                    let mut extractors: std::collections::HashMap<
                        String,
                        std::sync::Arc<dyn Fn(&str, &str) -> f32 + Send + Sync>,
                    > = std::collections::HashMap::new();
                    extractors.insert(
                        "has_unsafe".to_string(),
                        std::sync::Arc::new(
                            |code: &str, _| {
                                if code.contains("unsafe") {
                                    1.0
                                } else {
                                    0.0
                                }
                            },
                        ),
                    );
                    extractors.insert(
                        "has_raw_pointers".to_string(),
                        std::sync::Arc::new(|code: &str, _| {
                            if code.contains("*") || code.contains("mut") {
                                1.0
                            } else {
                                0.0
                            }
                        }),
                    );
                    extractors.insert(
                        "has_static_mut".to_string(),
                        std::sync::Arc::new(|code: &str, _| {
                            if code.contains("static mut") {
                                1.0
                            } else {
                                0.0
                            }
                        }),
                    );
                    extractors.insert(
                        "has_unchecked".to_string(),
                        std::sync::Arc::new(
                            |code: &str, _| {
                                if code.contains("unchecked") {
                                    1.0
                                } else {
                                    0.0
                                }
                            },
                        ),
                    );
                    extractors.insert(
                        "has_transmute".to_string(),
                        std::sync::Arc::new(
                            |code: &str, _| {
                                if code.contains("transmute") {
                                    1.0
                                } else {
                                    0.0
                                }
                            },
                        ),
                    );
                    extractors
                },
            },
        );

        // Python feature extractor
        language_extractors.insert(
            "python".to_string(),
            LanguageFeatureExtractor {
                language: "python".to_string(),
                feature_types: vec![
                    "has_eval".to_string(),
                    "has_exec".to_string(),
                    "has_pickle".to_string(),
                    "has_subprocess".to_string(),
                    "has_os_system".to_string(),
                ],
                extractors: {
                    let mut extractors: std::collections::HashMap<
                        String,
                        std::sync::Arc<dyn Fn(&str, &str) -> f32 + Send + Sync>,
                    > = std::collections::HashMap::new();
                    extractors.insert(
                        "has_eval".to_string(),
                        std::sync::Arc::new(
                            |code: &str, _| {
                                if code.contains("eval") {
                                    1.0
                                } else {
                                    0.0
                                }
                            },
                        ),
                    );
                    extractors.insert(
                        "has_exec".to_string(),
                        std::sync::Arc::new(
                            |code: &str, _| {
                                if code.contains("exec") {
                                    1.0
                                } else {
                                    0.0
                                }
                            },
                        ),
                    );
                    extractors.insert(
                        "has_pickle".to_string(),
                        std::sync::Arc::new(
                            |code: &str, _| {
                                if code.contains("pickle") {
                                    1.0
                                } else {
                                    0.0
                                }
                            },
                        ),
                    );
                    extractors.insert(
                        "has_subprocess".to_string(),
                        std::sync::Arc::new(|code: &str, _| {
                            if code.contains("subprocess") {
                                1.0
                            } else {
                                0.0
                            }
                        }),
                    );
                    extractors.insert(
                        "has_os_system".to_string(),
                        std::sync::Arc::new(
                            |code: &str, _| {
                                if code.contains("os.system") {
                                    1.0
                                } else {
                                    0.0
                                }
                            },
                        ),
                    );
                    extractors
                },
            },
        );

        Ok(Self {
            language_extractors,
        })
    }

    /// Extract features from code
    pub fn extract_features(&self, code: &str, language: &str) -> Result<Vec<f32>> {
        let extractor = self
            .language_extractors
            .get(language)
            .ok_or_else(|| anyhow::anyhow!("Unsupported language: {}", language))?;

        let mut features = Vec::new();

        for feature_name in &extractor.feature_types {
            if let Some(extractor_fn) = extractor.extractors.get(feature_name) {
                let value = extractor_fn(code, language);
                features.push(value);
            } else {
                features.push(0.0); // Default value
            }
        }

        Ok(features)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_semantic_analyzer_creation() {
        let config = crate::vulnerability_scanner::VulnerabilityScannerConfig::default();
        let analyzer = SemanticAnalyzer::new(&config).unwrap();
        assert!(!analyzer.gnn_layers.is_empty());
        assert!(!analyzer.vulnerability_patterns.is_empty());
    }

    #[test]
    fn test_code_analysis() {
        let config = crate::vulnerability_scanner::VulnerabilityScannerConfig::default();
        let analyzer = SemanticAnalyzer::new(&config).unwrap();

        let code = r#"
fn main() {
    let arr = [1, 2, 3];
    let i = 5; // This could cause buffer overflow
    println!("{}", arr[i]);
}
"#;

        let result = analyzer.analyze(code, "test.rs", "rust").unwrap();
        assert_eq!(result.vulnerabilities.len(), 0); // May not detect without proper training
    }

    #[test]
    fn test_feature_extraction() {
        let config = crate::vulnerability_scanner::VulnerabilityScannerConfig::default();
        let analyzer = SemanticAnalyzer::new(&config).unwrap();

        let rust_code = "unsafe { *ptr = 42 }";
        let features = analyzer.extract_features(rust_code, "rust").unwrap();
        assert!(features[0] > 0.0); // has_unsafe

        let python_code = "eval(user_input)";
        let features = analyzer.extract_features(python_code, "python").unwrap();
        assert!(features[0] > 0.0); // has_eval
    }

    #[test]
    fn test_vulnerability_patterns() {
        let config = crate::vulnerability_scanner::VulnerabilityScannerConfig::default();
        let analyzer = SemanticAnalyzer::new(&config).unwrap();

        let patterns = analyzer.get_vulnerability_patterns();
        assert!(patterns.contains_key("buffer_overflow"));
        assert!(patterns.contains_key("sql_injection"));
        assert!(patterns.contains_key("race_condition"));

        let buffer_overflow_pattern = &patterns["buffer_overflow"];
        assert_eq!(
            buffer_overflow_pattern.category,
            VulnerabilityCategory::MemorySafety
        );
        assert_eq!(
            buffer_overflow_pattern.severity,
            VulnerabilitySeverity::Critical
        );
    }
}
