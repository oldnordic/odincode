use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Graph node representing a code element
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GraphNode {
    pub id: String,
    pub node_type: String,
    pub code: String,
    pub features: Vec<f32>,
    pub line_number: usize,
    pub file_path: String,
}

/// Graph edge representing relationships between code elements
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GraphEdge {
    pub from: String,
    pub to: String,
    pub edge_type: String,
    pub weight: f32,
}

/// Code graph representation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CodeGraph {
    pub nodes: HashMap<String, GraphNode>,
    pub edges: Vec<GraphEdge>,
    pub adjacency: HashMap<String, Vec<(String, String)>>, // node_id -> [(neighbor_id, edge_type)]
}

/// GNN layer for neural network processing
#[derive(Debug, Clone)]
pub struct GNNLayer {
    pub input_dim: usize,
    pub output_dim: usize,
    pub weights: Vec<Vec<f32>>,
    pub activation: String,
}

impl GNNLayer {
    pub fn new(input_dim: usize, output_dim: usize, activation: String) -> Self {
        let weights = (0..output_dim)
            .map(|_| {
                (0..input_dim)
                    .map(|_| rand::random::<f32>() * 2.0 - 1.0)
                    .collect()
            })
            .collect();

        Self {
            input_dim,
            output_dim,
            weights,
            activation,
        }
    }

    pub fn forward(&self, inputs: &Vec<f32>) -> Vec<f32> {
        let mut outputs = vec![0.0; self.output_dim];

        for i in 0..self.output_dim {
            for j in 0..self.input_dim {
                outputs[i] += self.weights[i][j] * inputs[j];
            }

            // Apply activation
            match self.activation.as_str() {
                "relu" => outputs[i] = outputs[i].max(0.0),
                "sigmoid" => outputs[i] = 1.0 / (1.0 + (-outputs[i]).exp()),
                "tanh" => outputs[i] = outputs[i].tanh(),
                _ => {}
            }
        }

        outputs
    }
}

/// Vulnerability pattern definition
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityPattern {
    pub name: String,
    pub description: String,
    pub category: VulnerabilityCategory,
    pub severity: VulnerabilitySeverity,
    pub node_patterns: Vec<NodePattern>,
    pub edge_patterns: Vec<EdgePattern>,
    pub constraints: Vec<GraphConstraint>,
    pub feature_constraints: Vec<FeatureConstraint>,
}

/// Node pattern for matching graph nodes
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NodePattern {
    pub node_type: String,
    pub code_patterns: Vec<String>,
    pub feature_requirements: HashMap<String, f32>,
}

/// Edge pattern for matching graph edges
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EdgePattern {
    pub from_type: String,
    pub to_type: String,
    pub edge_type: String,
    pub required: bool,
}

/// Graph constraint for structural validation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum GraphConstraint {
    NodeDegree {
        node_type: String,
        min_degree: usize,
        max_degree: usize,
    },
    PathExists {
        from_type: String,
        to_type: String,
        edge_type: String,
    },
    NoCycle {
        node_type: String,
    },
    Connected {
        node_types: std::collections::HashSet<String>,
    },
}

/// Feature constraint for node feature validation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FeatureConstraint {
    pub feature_name: String,
    pub min_value: Option<f32>,
    pub max_value: Option<f32>,
    pub expected_value: Option<f32>,
}

/// Vulnerability category
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum VulnerabilityCategory {
    MemorySafety,
    Injection,
    Concurrency,
    Cryptography,
    InputValidation,
    Authentication,
    Authorization,
    Configuration,
    Other,
}

/// Vulnerability severity
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq)]
pub enum VulnerabilitySeverity {
    Low,
    Medium,
    High,
    Critical,
}

/// Language-specific feature extractor
#[derive(Clone)]
pub struct LanguageFeatureExtractor {
    pub language: String,
    pub feature_types: Vec<String>,
    pub extractors: HashMap<String, std::sync::Arc<dyn Fn(&str, &str) -> f32 + Send + Sync>>,
}

/// Feature extractor for code analysis
#[derive(Clone)]
pub struct FeatureExtractor {
    pub language_extractors: HashMap<String, LanguageFeatureExtractor>,
}

/// Semantic analysis result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SemanticAnalysisResult {
    pub vulnerabilities: Vec<Vulnerability>,
    pub graph: CodeGraph,
    pub analysis_time: std::time::Duration,
}

/// Detected vulnerability
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    pub id: String,
    pub pattern_name: String,
    pub description: String,
    pub category: VulnerabilityCategory,
    pub severity: VulnerabilitySeverity,
    pub location: CodeLocation,
    pub confidence: f32,
    pub suggested_fix: String,
    pub cwe_id: Option<String>,
}

/// Code location information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CodeLocation {
    pub file_path: String,
    pub line_number: usize,
    pub column_number: Option<usize>,
    pub code_snippet: String,
}
