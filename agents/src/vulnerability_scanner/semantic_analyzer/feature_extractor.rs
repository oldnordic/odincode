use crate::vulnerability_scanner::semantic_analyzer::types::*;
use anyhow::Result;

/// Feature extraction utilities for code analysis
pub struct FeatureExtractorImpl;

impl FeatureExtractorImpl {
    /// Extract features from a code node
    pub fn extract_node_features(node: &GraphNode, language: &str) -> Result<Vec<f32>> {
        let mut features = Vec::new();

        // Basic code features
        features.push(Self::extract_code_length_feature(node));
        features.push(Self::extract_complexity_feature(node));
        features.push(Self::extract_nesting_level_feature(node));
        features.push(Self::extract_comment_ratio_feature(node));

        // Language-specific features
        match language {
            "rust" => {
                features.extend(Self::extract_rust_features(node));
            }
            "python" => {
                features.extend(Self::extract_python_features(node));
            }
            "javascript" | "typescript" => {
                features.extend(Self::extract_javascript_features(node));
            }
            "c" | "cpp" | "c++" => {
                features.extend(Self::extract_c_features(node));
            }
            _ => {
                // Generic features for unsupported languages
                features.extend(Self::extract_generic_features(node));
            }
        }

        // Security-specific features
        features.extend(Self::extract_security_features(node));

        Ok(features)
    }

    /// Extract code length feature
    fn extract_code_length_feature(node: &GraphNode) -> f32 {
        let length = node.code.len() as f32;
        // Normalize to 0-1 range (assuming max reasonable line length is 200)
        (length / 200.0).min(1.0)
    }

    /// Extract complexity feature based on code structure
    fn extract_complexity_feature(node: &GraphNode) -> f32 {
        let code = &node.code;
        let mut complexity = 0.0;

        // Count control structures
        complexity += (code.matches("if").count() as f32) * 0.2;
        complexity += (code.matches("else").count() as f32) * 0.1;
        complexity += (code.matches("for").count() as f32) * 0.3;
        complexity += (code.matches("while").count() as f32) * 0.3;
        complexity += (code.matches("match").count() as f32) * 0.4;
        complexity += (code.matches("switch").count() as f32) * 0.3;

        // Count operators
        complexity += (code.matches("&&").count() as f32) * 0.1;
        complexity += (code.matches("||").count() as f32) * 0.1;
        complexity += (code.matches("?:").count() as f32) * 0.2;

        // Normalize to 0-1 range
        complexity.min(1.0)
    }

    /// Extract nesting level feature
    fn extract_nesting_level_feature(node: &GraphNode) -> f32 {
        let code = &node.code;
        let mut nesting_level = 0;

        // Count opening braces/brackets/parentheses
        nesting_level += code.matches('{').count();
        nesting_level += code.matches('[').count();
        nesting_level += code.matches('(').count();

        // Subtract closing braces/brackets/parentheses
        nesting_level -= code.matches('}').count();
        nesting_level -= code.matches(']').count();
        nesting_level -= code.matches(')').count();

        // Normalize to 0-1 range (assuming max nesting level of 5)
        (nesting_level as f32 / 5.0).max(0.0).min(1.0)
    }

    /// Extract comment ratio feature
    fn extract_comment_ratio_feature(node: &GraphNode) -> f32 {
        let code = &node.code;
        let total_chars = code.len();

        if total_chars == 0 {
            return 0.0;
        }

        let comment_chars = code.matches("//").count() * 2 + code.matches("/*").count() * 2;
        let comment_ratio = comment_chars as f32 / total_chars as f32;

        comment_ratio.min(1.0)
    }

    /// Extract Rust-specific features
    fn extract_rust_features(node: &GraphNode) -> Vec<f32> {
        let code = &node.code.to_lowercase();
        let mut features = Vec::new();

        // Unsafe code features
        features.push(if code.contains("unsafe") { 1.0 } else { 0.0 });
        features.push(if code.contains("*") || code.contains("mut") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("static mut") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("unchecked") { 1.0 } else { 0.0 });
        features.push(if code.contains("transmute") { 1.0 } else { 0.0 });

        // Ownership features
        features.push(if code.contains("box") { 1.0 } else { 0.0 });
        features.push(if code.contains("rc") || code.contains("arc") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("ref") || code.contains("&mut") {
            1.0
        } else {
            0.0
        });

        // Concurrency features
        features.push(if code.contains("thread") || code.contains("spawn") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("mutex") || code.contains("rwlock") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("atomic") { 1.0 } else { 0.0 });
        features.push(if code.contains("channel") || code.contains("mpsc") {
            1.0
        } else {
            0.0
        });

        features
    }

    /// Extract Python-specific features
    fn extract_python_features(node: &GraphNode) -> Vec<f32> {
        let code = &node.code.to_lowercase();
        let mut features = Vec::new();

        // Dynamic execution features
        features.push(if code.contains("eval") { 1.0 } else { 0.0 });
        features.push(if code.contains("exec") { 1.0 } else { 0.0 });
        features.push(if code.contains("compile") { 1.0 } else { 0.0 });

        // Serialization features
        features.push(if code.contains("pickle") { 1.0 } else { 0.0 });
        features.push(if code.contains("marshal") { 1.0 } else { 0.0 });
        features.push(if code.contains("json") { 1.0 } else { 0.0 });

        // System interaction features
        features.push(if code.contains("subprocess") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("os.system") { 1.0 } else { 0.0 });
        features.push(if code.contains("commands") { 1.0 } else { 0.0 });

        // File operation features
        features.push(if code.contains("open") && code.contains("w") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("file") { 1.0 } else { 0.0 });
        features.push(if code.contains("pathlib") { 1.0 } else { 0.0 });

        // Network features
        features.push(if code.contains("socket") { 1.0 } else { 0.0 });
        features.push(if code.contains("urllib") || code.contains("requests") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("http") { 1.0 } else { 0.0 });

        features
    }

    /// Extract JavaScript/TypeScript-specific features
    fn extract_javascript_features(node: &GraphNode) -> Vec<f32> {
        let code = &node.code.to_lowercase();
        let mut features = Vec::new();

        // Dynamic execution features
        features.push(if code.contains("eval") { 1.0 } else { 0.0 });
        features.push(if code.contains("function(") || code.contains("=>") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("new function") {
            1.0
        } else {
            0.0
        });

        // DOM manipulation features
        features.push(if code.contains("innerhtml") { 1.0 } else { 0.0 });
        features.push(if code.contains("document.write") {
            1.0
        } else {
            0.0
        });
        features.push(
            if code.contains("settimeout") || code.contains("setinterval") {
                1.0
            } else {
                0.0
            },
        );

        // Network features
        features.push(if code.contains("fetch") { 1.0 } else { 0.0 });
        features.push(if code.contains("xmlhttprequest") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("ajax") { 1.0 } else { 0.0 });

        // Storage features
        features.push(if code.contains("localstorage") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("sessionstorage") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("cookie") { 1.0 } else { 0.0 });

        features
    }

    /// Extract C/C++ specific features
    fn extract_c_features(node: &GraphNode) -> Vec<f32> {
        let code = &node.code.to_lowercase();
        let mut features = Vec::new();

        // Memory management features
        features.push(if code.contains("malloc") || code.contains("free") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("calloc") || code.contains("realloc") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("new") || code.contains("delete") {
            1.0
        } else {
            0.0
        });

        // Pointer features
        features.push(if code.contains("*") { 1.0 } else { 0.0 });
        features.push(if code.contains("&") { 1.0 } else { 0.0 });
        features.push(if code.contains("->") { 1.0 } else { 0.0 });

        // Array features
        features.push(if code.contains("[") && code.contains("]") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("strcpy") || code.contains("strcat") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("sprintf") || code.contains("scanf") {
            1.0
        } else {
            0.0
        });

        // Thread features
        features.push(if code.contains("pthread") { 1.0 } else { 0.0 });
        features.push(if code.contains("thread") { 1.0 } else { 0.0 });
        features.push(if code.contains("mutex") { 1.0 } else { 0.0 });

        features
    }

    /// Extract generic features for unsupported languages
    fn extract_generic_features(node: &GraphNode) -> Vec<f32> {
        let code = &node.code.to_lowercase();
        let mut features = Vec::new();

        // Basic control flow
        features.push(if code.contains("if") { 1.0 } else { 0.0 });
        features.push(if code.contains("for") { 1.0 } else { 0.0 });
        features.push(if code.contains("while") { 1.0 } else { 0.0 });

        // Function calls
        features.push(if code.contains("(") && code.contains(")") {
            1.0
        } else {
            0.0
        });

        // Assignment
        features.push(if code.contains("=") { 1.0 } else { 0.0 });

        // Arrays/Lists
        features.push(if code.contains("[") && code.contains("]") {
            1.0
        } else {
            0.0
        });

        features
    }

    /// Extract security-specific features
    fn extract_security_features(node: &GraphNode) -> Vec<f32> {
        let code = &node.code.to_lowercase();
        let mut features = Vec::new();

        // Input validation features
        features.push(
            if code.contains("input") || code.contains("get") || code.contains("read") {
                1.0
            } else {
                0.0
            },
        );
        features.push(if code.contains("validate") || code.contains("sanitize") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("escape") || code.contains("encode") {
            1.0
        } else {
            0.0
        });

        // Authentication features
        features.push(if code.contains("password") || code.contains("auth") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("login") || code.contains("session") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("token") || code.contains("jwt") {
            1.0
        } else {
            0.0
        });

        // Cryptography features
        features.push(if code.contains("encrypt") || code.contains("decrypt") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("hash") || code.contains("md5") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("sha") || code.contains("aes") {
            1.0
        } else {
            0.0
        });

        // Network features
        features.push(if code.contains("http") || code.contains("url") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("tcp") || code.contains("udp") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("socket") || code.contains("port") {
            1.0
        } else {
            0.0
        });

        // File system features
        features.push(if code.contains("file") || code.contains("path") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("open") || code.contains("read") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("write") || code.contains("delete") {
            1.0
        } else {
            0.0
        });

        // Process execution features
        features.push(if code.contains("exec") || code.contains("system") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("shell") || code.contains("cmd") {
            1.0
        } else {
            0.0
        });
        features.push(if code.contains("run") || code.contains("spawn") {
            1.0
        } else {
            0.0
        });

        features
    }

    /// Extract features for graph neural network processing
    pub fn extract_gnn_features(graph: &CodeGraph) -> Result<Vec<Vec<f32>>> {
        let mut all_features = Vec::new();

        for node in graph.nodes.values() {
            let mut node_features = Vec::new();

            // Node type features (one-hot encoded)
            let node_types = vec![
                "statement",
                "function",
                "conditional",
                "loop",
                "array_access",
                "pointer_arithmetic",
                "concurrency",
                "user_input",
                "string_concatenation",
                "sql_query",
            ];

            for node_type in &node_types {
                node_features.push(if node.node_type == *node_type {
                    1.0
                } else {
                    0.0
                });
            }

            // Structural features
            node_features.push(Self::extract_degree_feature(graph, &node.id));
            node_features.push(Self::extract_centrality_feature(graph, &node.id));
            node_features.push(Self::extract_clustering_feature(graph, &node.id));

            // Code features
            node_features.push(Self::extract_code_length_feature(node));
            node_features.push(Self::extract_complexity_feature(node));

            all_features.push(node_features);
        }

        Ok(all_features)
    }

    /// Extract node degree feature
    fn extract_degree_feature(graph: &CodeGraph, node_id: &str) -> f32 {
        let degree = graph.adjacency.get(node_id).map_or(0, |adj| adj.len());
        // Normalize to 0-1 range (assuming max degree of 10)
        (degree as f32 / 10.0).min(1.0)
    }

    /// Extract node centrality feature (simplified)
    fn extract_centrality_feature(graph: &CodeGraph, node_id: &str) -> f32 {
        let total_nodes = graph.nodes.len();
        if total_nodes == 0 {
            return 0.0;
        }

        let reachable_nodes = Self::count_reachable_nodes(graph, node_id);
        // Normalize to 0-1 range
        (reachable_nodes as f32 / total_nodes as f32).min(1.0)
    }

    /// Extract clustering coefficient feature (simplified)
    fn extract_clustering_feature(graph: &CodeGraph, node_id: &str) -> f32 {
        let neighbors = graph
            .adjacency
            .get(node_id)
            .map_or(Vec::new(), |adj| adj.clone());

        if neighbors.len() < 2 {
            return 0.0;
        }

        let mut connections = 0;
        let possible_connections = neighbors.len() * (neighbors.len() - 1) / 2;

        for i in 0..neighbors.len() {
            for j in i + 1..neighbors.len() {
                if Self::are_connected(graph, &neighbors[i].0, &neighbors[j].0) {
                    connections += 1;
                }
            }
        }

        if possible_connections == 0 {
            0.0
        } else {
            connections as f32 / possible_connections as f32
        }
    }

    /// Count reachable nodes from a given node
    fn count_reachable_nodes(graph: &CodeGraph, node_id: &str) -> usize {
        let mut visited = std::collections::HashSet::new();
        let mut queue = std::collections::VecDeque::new();
        queue.push_back(node_id.to_string());

        while let Some(current) = queue.pop_front() {
            if visited.contains(&current) {
                continue;
            }

            visited.insert(current.clone());

            if let Some(neighbors) = graph.adjacency.get(&current) {
                for (neighbor, _) in neighbors {
                    if !visited.contains(neighbor) {
                        queue.push_back(neighbor.clone());
                    }
                }
            }
        }

        visited.len()
    }

    /// Check if two nodes are connected
    fn are_connected(graph: &CodeGraph, node1_id: &str, node2_id: &str) -> bool {
        if let Some(neighbors) = graph.adjacency.get(node1_id) {
            for (neighbor_id, _) in neighbors {
                if neighbor_id == node2_id {
                    return true;
                }
            }
        }
        false
    }
}
