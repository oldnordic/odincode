use crate::vulnerability_scanner::semantic_analyzer::types::*;
use anyhow::Result;

/// Graph builder utilities for constructing CodeGraph from code
pub struct GraphBuilder;

impl GraphBuilder {
    /// Create a new code graph from source code
    pub fn build_graph(code: &str, file_path: &str) -> Result<CodeGraph> {
        let mut graph = CodeGraph {
            nodes: std::collections::HashMap::new(),
            edges: Vec::new(),
            adjacency: std::collections::HashMap::new(),
        };

        let lines: Vec<&str> = code.lines().collect();
        let mut node_id_counter = 0;

        // Parse code and create nodes
        for (line_num, line) in lines.iter().enumerate() {
            let node_type = Self::determine_node_type(line);
            let node_id = format!("node_{}", node_id_counter);
            node_id_counter += 1;

            let node = GraphNode {
                id: node_id.clone(),
                node_type: node_type.clone(),
                code: line.to_string(),
                features: Vec::new(), // Will be populated later
                line_number: line_num + 1,
                file_path: file_path.to_string(),
            };

            graph.nodes.insert(node_id, node);
        }

        // Create edges based on code relationships
        Self::create_edges(&mut graph, &lines)?;

        Ok(graph)
    }

    /// Determine the type of a code node based on its content
    pub fn determine_node_type(code: &str) -> String {
        let code_lower = code.to_lowercase();

        if code_lower.contains("select")
            || code_lower.contains("insert")
            || code_lower.contains("update")
            || code_lower.contains("delete")
        {
            "sql_query".to_string()
        } else if code_lower.contains("for ")
            || code_lower.contains("while ")
            || code_lower.contains("loop")
        {
            "loop".to_string()
        } else if code_lower.contains("if ")
            || code_lower.contains("else if")
            || code_lower.contains("match ")
        {
            "conditional".to_string()
        } else if code_lower.contains("fn ")
            || code_lower.contains("def ")
            || code_lower.contains("function ")
            || code_lower.contains("func ")
        {
            "function".to_string()
        } else if code.contains("[") && code.contains("]") {
            "array_access".to_string()
        } else if code.contains("*") || code.contains("&") || code.contains("ptr") {
            "pointer_arithmetic".to_string()
        } else if code_lower.contains("thread")
            || code_lower.contains("async")
            || code_lower.contains("await")
            || code_lower.contains("spawn")
        {
            "concurrency".to_string()
        } else if code_lower.contains("input")
            || code_lower.contains("read")
            || code_lower.contains("get")
        {
            "user_input".to_string()
        } else if code.contains("+") && (code.contains("\"") || code.contains("'")) {
            "string_concatenation".to_string()
        } else {
            "statement".to_string()
        }
    }

    /// Create edges between nodes based on code relationships
    fn create_edges(graph: &mut CodeGraph, lines: &[&str]) -> Result<()> {
        let node_ids: Vec<String> = graph.nodes.keys().cloned().collect();

        for i in 0..node_ids.len() {
            for j in i + 1..node_ids.len() {
                let from_node = &graph.nodes[&node_ids[i]];
                let to_node = &graph.nodes[&node_ids[j]];

                // Create edges based on code relationships
                if Self::should_create_edge(from_node, to_node, lines) {
                    let edge_type = Self::determine_edge_type(from_node, to_node);
                    let weight = Self::calculate_edge_weight(from_node, to_node);

                    let edge = GraphEdge {
                        from: from_node.id.clone(),
                        to: to_node.id.clone(),
                        edge_type: edge_type.clone(),
                        weight,
                    };

                    graph.edges.push(edge);

                    // Update adjacency list
                    graph
                        .adjacency
                        .entry(from_node.id.clone())
                        .or_insert_with(Vec::new)
                        .push((to_node.id.clone(), edge_type));
                }
            }
        }

        Ok(())
    }

    /// Determine if an edge should be created between two nodes
    fn should_create_edge(from_node: &GraphNode, to_node: &GraphNode, lines: &[&str]) -> bool {
        // Simple heuristic: create edges between nodes that are close in the code
        // and have related functionality
        let line_distance = (to_node.line_number as i32 - from_node.line_number as i32).abs();

        if line_distance > 5 {
            return false;
        }

        // Check for variable usage relationships
        let from_vars = Self::extract_variables(&from_node.code);
        let to_vars = Self::extract_variables(&to_node.code);

        // If to_node uses variables defined in from_node, create edge
        for to_var in &to_vars {
            if from_vars.contains(to_var) {
                return true;
            }
        }

        // Check for control flow relationships
        if (from_node.node_type == "conditional" || from_node.node_type == "loop")
            && (to_node.node_type != "function")
        {
            return true;
        }

        // Check for function call relationships
        if from_node.node_type == "function" && to_node.code.contains(&from_node.code) {
            return true;
        }

        false
    }

    /// Extract variable names from code
    fn extract_variables(code: &str) -> Vec<String> {
        let mut variables = Vec::new();

        // Simple variable extraction - looks for patterns like "let x =", "x =", etc.
        let words: Vec<&str> = code.split_whitespace().collect();

        for i in 0..words.len() {
            if words[i] == "let" || words[i] == "var" || words[i] == "const" {
                if i + 1 < words.len() {
                    let var_name = words[i + 1].trim_end_matches(':').trim_end_matches(',');
                    if !var_name.is_empty() && !var_name.contains('(') {
                        variables.push(var_name.to_string());
                    }
                }
            } else if words[i].contains('=') && i > 0 {
                let var_name = words[i - 1].trim_end_matches(':');
                if !var_name.is_empty() && !var_name.contains('(') {
                    variables.push(var_name.to_string());
                }
            }
        }

        variables
    }

    /// Determine the type of edge between two nodes
    fn determine_edge_type(from_node: &GraphNode, to_node: &GraphNode) -> String {
        if from_node.node_type == "function" {
            "function_call".to_string()
        } else if from_node.node_type == "conditional" || from_node.node_type == "loop" {
            "control_flow".to_string()
        } else if from_node.node_type == "user_input" && to_node.node_type != "function" {
            "data_flow".to_string()
        } else if to_node.node_type == "array_access" || to_node.node_type == "pointer_arithmetic" {
            "memory_access".to_string()
        } else {
            "general".to_string()
        }
    }

    /// Calculate the weight of an edge based on node relationship strength
    fn calculate_edge_weight(from_node: &GraphNode, to_node: &GraphNode) -> f32 {
        let line_distance = (to_node.line_number as i32 - from_node.line_number as i32).abs();
        let distance_weight = 1.0 / (1.0 + line_distance as f32);

        let type_weight = match (&from_node.node_type as &str, &to_node.node_type as &str) {
            ("function", _) => 0.9,
            ("conditional", _) => 0.8,
            ("loop", _) => 0.8,
            ("user_input", _) => 0.7,
            (_, "array_access") => 0.6,
            (_, "pointer_arithmetic") => 0.6,
            _ => 0.5,
        };

        distance_weight * type_weight
    }

    /// Add a node to the graph
    pub fn add_node(graph: &mut CodeGraph, node: GraphNode) {
        graph.nodes.insert(node.id.clone(), node);
    }

    /// Add an edge to the graph
    pub fn add_edge(graph: &mut CodeGraph, edge: GraphEdge) {
        graph.edges.push(edge.clone());

        // Update adjacency list
        graph
            .adjacency
            .entry(edge.from.clone())
            .or_insert_with(Vec::new)
            .push((edge.to.clone(), edge.edge_type));
    }

    /// Remove a node from the graph
    pub fn remove_node(graph: &mut CodeGraph, node_id: &str) {
        graph.nodes.remove(node_id);
        graph.adjacency.remove(node_id);

        // Remove edges connected to this node
        graph
            .edges
            .retain(|edge| edge.from != node_id && edge.to != node_id);

        // Remove from adjacency lists
        for (_, neighbors) in graph.adjacency.iter_mut() {
            neighbors.retain(|(neighbor_id, _)| neighbor_id != node_id);
        }
    }

    /// Get neighbors of a node
    pub fn get_neighbors<'a>(graph: &'a CodeGraph, node_id: &'a str) -> Vec<&'a GraphNode> {
        let mut neighbors = Vec::new();

        if let Some(adjacent_nodes) = graph.adjacency.get(node_id) {
            for (neighbor_id, _) in adjacent_nodes {
                if let Some(node) = graph.nodes.get(neighbor_id) {
                    neighbors.push(node);
                }
            }
        }

        neighbors
    }

    /// Get the degree of a node (number of connected edges)
    pub fn get_node_degree(graph: &CodeGraph, node_id: &str) -> usize {
        graph.adjacency.get(node_id).map_or(0, |adj| adj.len())
    }

    /// Check if the graph contains a cycle
    pub fn has_cycle(graph: &CodeGraph) -> bool {
        let mut visited = std::collections::HashSet::new();
        let mut recursion_stack = std::collections::HashSet::new();

        for node_id in graph.nodes.keys() {
            if !visited.contains(node_id) {
                if Self::dfs_has_cycle(graph, node_id, &mut visited, &mut recursion_stack) {
                    return true;
                }
            }
        }

        false
    }

    /// Depth-first search helper for cycle detection
    fn dfs_has_cycle(
        graph: &CodeGraph,
        node_id: &str,
        visited: &mut std::collections::HashSet<String>,
        recursion_stack: &mut std::collections::HashSet<String>,
    ) -> bool {
        visited.insert(node_id.to_string());
        recursion_stack.insert(node_id.to_string());

        if let Some(neighbors) = graph.adjacency.get(node_id) {
            for (neighbor_id, _) in neighbors {
                if !visited.contains(neighbor_id) {
                    if Self::dfs_has_cycle(graph, neighbor_id, visited, recursion_stack) {
                        return true;
                    }
                } else if recursion_stack.contains(neighbor_id) {
                    return true;
                }
            }
        }

        recursion_stack.remove(node_id);
        false
    }
}
