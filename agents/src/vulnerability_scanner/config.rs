//! Vulnerability Scanner Configuration
//!
//! This module contains the configuration for the AEGIS-BUGS vulnerability scanner.

use serde::{Deserialize, Serialize};
use std::path::PathBuf;

/// Configuration for the AEGIS-BUGS vulnerability scanner
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityScannerConfig {
    /// Enable/disable pattern-based detection
    pub enable_pattern_detection: bool,
    /// Enable/disable semantic analysis with GNN
    pub enable_semantic_analysis: bool,
    /// Enable/disable machine learning detection
    pub enable_ml_detection: bool,
    /// Confidence threshold for reporting vulnerabilities (0.0 to 1.0)
    pub confidence_threshold: f64,
    /// Maximum number of findings to report per file
    pub max_findings_per_file: usize,
    /// Languages to scan (empty list means all supported languages)
    pub target_languages: Vec<String>,
    /// Vulnerability categories to check (empty list means all categories)
    pub target_categories: Vec<VulnerabilityCategory>,
    /// Path to ML model files
    pub model_path: PathBuf,
    /// Path to pattern databases
    pub pattern_database_path: PathBuf,
    /// GNN model configuration
    pub gnn_config: GNNConfig,
    /// Performance settings
    pub performance_config: PerformanceConfig,
    /// Logging configuration
    pub logging_config: LoggingConfig,
}

/// GNN (Graph Neural Network) configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GNNConfig {
    /// Number of hidden layers in the GNN
    pub hidden_layers: usize,
    /// Hidden dimension size
    pub hidden_dim: usize,
    /// Number of attention heads
    pub attention_heads: usize,
    /// Dropout rate
    pub dropout_rate: f64,
    /// Learning rate
    pub learning_rate: f64,
    /// Number of training epochs
    pub epochs: usize,
    /// Batch size for training
    pub batch_size: usize,
    /// Enable graph attention mechanisms
    pub enable_attention: bool,
    /// Enable residual connections
    pub enable_residual: bool,
    /// Enable batch normalization
    pub enable_batch_norm: bool,
}

/// Performance configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PerformanceConfig {
    /// Maximum file size to scan (in bytes)
    pub max_file_size_bytes: usize,
    /// Timeout for pattern detection (in seconds)
    pub pattern_detection_timeout_secs: u64,
    /// Timeout for semantic analysis (in seconds)
    pub semantic_analysis_timeout_secs: u64,
    /// Timeout for ML detection (in seconds)
    pub ml_detection_timeout_secs: u64,
    /// Enable parallel processing
    pub enable_parallel_processing: bool,
    /// Maximum number of parallel workers
    pub max_parallel_workers: usize,
    /// Enable caching of analysis results
    pub enable_caching: bool,
    /// Cache expiration time (in seconds)
    pub cache_expiry_secs: u64,
}

/// Logging configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LoggingConfig {
    /// Enable detailed logging
    pub enable_detailed_logging: bool,
    /// Log level for vulnerability findings
    pub finding_log_level: String,
    /// Enable performance metrics logging
    pub enable_performance_logging: bool,
    /// Log file path (empty means stdout only)
    pub log_file_path: Option<PathBuf>,
    /// Maximum log file size (in MB)
    pub max_log_file_size_mb: usize,
    /// Number of log files to rotate
    pub log_rotation_count: usize,
}

/// Vulnerability category for configuration
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum VulnerabilityCategory {
    /// Security vulnerabilities
    Security,
    /// Performance issues
    Performance,
    /// Memory safety issues
    MemorySafety,
    /// Concurrency issues
    Concurrency,
    /// Input validation issues
    InputValidation,
    /// Authentication/Authorization issues
    Auth,
    /// Data handling issues
    DataHandling,
    /// Code quality issues
    CodeQuality,
}

impl Default for VulnerabilityScannerConfig {
    fn default() -> Self {
        Self {
            enable_pattern_detection: true,
            enable_semantic_analysis: true,
            enable_ml_detection: true,
            confidence_threshold: 0.7,
            max_findings_per_file: 100,
            target_languages: vec![
                "rust".to_string(),
                "python".to_string(),
                "javascript".to_string(),
                "typescript".to_string(),
                "go".to_string(),
            ],
            target_categories: vec![
                VulnerabilityCategory::Security,
                VulnerabilityCategory::MemorySafety,
                VulnerabilityCategory::Performance,
            ],
            model_path: PathBuf::from("./models"),
            pattern_database_path: PathBuf::from("./patterns"),
            gnn_config: GNNConfig::default(),
            performance_config: PerformanceConfig::default(),
            logging_config: LoggingConfig::default(),
        }
    }
}

impl Default for GNNConfig {
    fn default() -> Self {
        Self {
            hidden_layers: 3,
            hidden_dim: 256,
            attention_heads: 8,
            dropout_rate: 0.1,
            learning_rate: 0.001,
            epochs: 100,
            batch_size: 32,
            enable_attention: true,
            enable_residual: true,
            enable_batch_norm: true,
        }
    }
}

impl Default for PerformanceConfig {
    fn default() -> Self {
        Self {
            max_file_size_bytes: 1024 * 1024, // 1MB
            pattern_detection_timeout_secs: 30,
            semantic_analysis_timeout_secs: 60,
            ml_detection_timeout_secs: 45,
            enable_parallel_processing: true,
            max_parallel_workers: 4,
            enable_caching: true,
            cache_expiry_secs: 3600, // 1 hour
        }
    }
}

impl Default for LoggingConfig {
    fn default() -> Self {
        Self {
            enable_detailed_logging: false,
            finding_log_level: "info".to_string(),
            enable_performance_logging: true,
            log_file_path: None,
            max_log_file_size_mb: 100,
            log_rotation_count: 5,
        }
    }
}

impl VulnerabilityScannerConfig {
    /// Validate the configuration
    pub fn validate(&self) -> Result<(), String> {
        // Validate confidence threshold
        if self.confidence_threshold < 0.0 || self.confidence_threshold > 1.0 {
            return Err("Confidence threshold must be between 0.0 and 1.0".to_string());
        }

        // Validate max findings per file
        if self.max_findings_per_file == 0 {
            return Err("Max findings per file must be greater than 0".to_string());
        }

        // Validate GNN configuration
        if self.gnn_config.hidden_layers == 0 {
            return Err("GNN hidden layers must be greater than 0".to_string());
        }
        if self.gnn_config.hidden_dim == 0 {
            return Err("GNN hidden dimension must be greater than 0".to_string());
        }
        if self.gnn_config.attention_heads == 0 {
            return Err("GNN attention heads must be greater than 0".to_string());
        }
        if self.gnn_config.dropout_rate < 0.0 || self.gnn_config.dropout_rate >= 1.0 {
            return Err("GNN dropout rate must be between 0.0 and 1.0".to_string());
        }
        if self.gnn_config.learning_rate <= 0.0 || self.gnn_config.learning_rate > 1.0 {
            return Err("GNN learning rate must be between 0.0 and 1.0".to_string());
        }
        if self.gnn_config.epochs == 0 {
            return Err("GNN epochs must be greater than 0".to_string());
        }
        if self.gnn_config.batch_size == 0 {
            return Err("GNN batch size must be greater than 0".to_string());
        }

        // Validate performance configuration
        if self.performance_config.max_file_size_bytes == 0 {
            return Err("Max file size must be greater than 0".to_string());
        }
        if self.performance_config.pattern_detection_timeout_secs == 0 {
            return Err("Pattern detection timeout must be greater than 0".to_string());
        }
        if self.performance_config.semantic_analysis_timeout_secs == 0 {
            return Err("Semantic analysis timeout must be greater than 0".to_string());
        }
        if self.performance_config.ml_detection_timeout_secs == 0 {
            return Err("ML detection timeout must be greater than 0".to_string());
        }
        if self.performance_config.max_parallel_workers == 0 {
            return Err("Max parallel workers must be greater than 0".to_string());
        }
        if self.performance_config.cache_expiry_secs == 0 {
            return Err("Cache expiry time must be greater than 0".to_string());
        }

        // Validate logging configuration
        if self.logging_config.max_log_file_size_mb == 0 {
            return Err("Max log file size must be greater than 0".to_string());
        }
        if self.logging_config.log_rotation_count == 0 {
            return Err("Log rotation count must be greater than 0".to_string());
        }

        Ok(())
    }

    /// Create a configuration optimized for speed
    pub fn optimized_for_speed() -> Self {
        let mut config = Self::default();
        config.enable_semantic_analysis = false; // Disable GNN for speed
        config.enable_ml_detection = false; // Disable ML for speed
        config.performance_config.enable_parallel_processing = true;
        config.performance_config.max_parallel_workers = 8;
        config.performance_config.enable_caching = true;
        config.confidence_threshold = 0.8; // Higher threshold for fewer false positives
        config
    }

    /// Create a configuration optimized for accuracy
    pub fn optimized_for_accuracy() -> Self {
        let mut config = Self::default();
        config.enable_pattern_detection = true;
        config.enable_semantic_analysis = true;
        config.enable_ml_detection = true;
        config.confidence_threshold = 0.5; // Lower threshold for more findings
        config.gnn_config.hidden_layers = 5; // Deeper GNN
        config.gnn_config.hidden_dim = 512; // Larger hidden dimension
        config.gnn_config.epochs = 200; // More training epochs
        config.performance_config.semantic_analysis_timeout_secs = 120; // Longer timeout
        config.performance_config.ml_detection_timeout_secs = 90; // Longer timeout
        config
    }

    /// Create a configuration optimized for memory usage
    pub fn optimized_for_memory() -> Self {
        let mut config = Self::default();
        config.enable_semantic_analysis = false; // Disable memory-intensive GNN
        config.enable_ml_detection = false; // Disable memory-intensive ML
        config.performance_config.max_parallel_workers = 1; // Single thread
        config.performance_config.enable_caching = false; // Disable caching to save memory
        config.performance_config.max_file_size_bytes = 512 * 1024; // Smaller max file size
        config
    }

    /// Load configuration from a file
    pub fn from_file<P: AsRef<std::path::Path>>(
        path: P,
    ) -> Result<Self, Box<dyn std::error::Error>> {
        let content = std::fs::read_to_string(path)?;
        let config: Self = serde_json::from_str(&content)?;
        config.validate()?;
        Ok(config)
    }

    /// Save configuration to a file
    pub fn to_file<P: AsRef<std::path::Path>>(
        &self,
        path: P,
    ) -> Result<(), Box<dyn std::error::Error>> {
        let content = serde_json::to_string_pretty(self)?;
        std::fs::write(path, content)?;
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_default_config_validation() {
        let config = VulnerabilityScannerConfig::default();
        assert!(config.validate().is_ok());
    }

    #[test]
    fn test_invalid_confidence_threshold() {
        let mut config = VulnerabilityScannerConfig::default();
        config.confidence_threshold = 1.5;
        assert!(config.validate().is_err());
    }

    #[test]
    fn test_optimized_for_speed() {
        let config = VulnerabilityScannerConfig::optimized_for_speed();
        assert!(!config.enable_semantic_analysis);
        assert!(!config.enable_ml_detection);
        assert!(config.confidence_threshold > 0.7);
    }

    #[test]
    fn test_optimized_for_accuracy() {
        let config = VulnerabilityScannerConfig::optimized_for_accuracy();
        assert!(config.enable_semantic_analysis);
        assert!(config.enable_ml_detection);
        assert!(config.confidence_threshold < 0.7);
    }

    #[test]
    fn test_optimized_for_memory() {
        let config = VulnerabilityScannerConfig::optimized_for_memory();
        assert!(!config.enable_semantic_analysis);
        assert!(!config.enable_ml_detection);
        assert_eq!(config.performance_config.max_parallel_workers, 1);
    }
}
