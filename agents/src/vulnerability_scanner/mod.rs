//! AEGIS-BUGS Vulnerability Scanner Module
//!
//! This module implements the AEGIS-BUGS (Advanced Enhanced Graph-based Intelligence System
//! for Bug Detection and Security Scanning) vulnerability detection system. It combines
//! static analysis, semantic analysis using graph neural networks, and machine learning
//! for comprehensive vulnerability detection across multiple programming languages.

pub mod config;
pub mod ml_detector;
pub mod pattern_detector;
pub mod semantic_analyzer;
pub mod utils;
pub mod utils_modules;

use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use uuid::Uuid;

use odincode_core::{CodeFile, CodeIssue, IssueType, Severity};
use odincode_ltmc::LTMManager;

use self::config::VulnerabilityScannerConfig;
use self::ml_detector::MLDetector;
use self::pattern_detector::PatternDetector;
use self::semantic_analyzer::SemanticAnalyzer;

/// Vulnerability severity levels
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum VulnerabilitySeverity {
    /// Critical severity - immediate action required
    Critical,
    /// High severity - should be addressed soon
    High,
    /// Medium severity - should be addressed
    Medium,
    /// Low severity - consider addressing
    Low,
    /// Informational - for awareness only
    Informational,
}

/// Vulnerability category
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum VulnerabilityCategory {
    /// Security vulnerabilities
    Security,
    /// Performance issues
    Performance,
    /// Memory safety issues
    MemorySafety,
    /// Concurrency issues
    Concurrency,
    /// Input validation issues
    InputValidation,
    /// Authentication/Authorization issues
    Auth,
    /// Data handling issues
    DataHandling,
    /// Code quality issues
    CodeQuality,
}

/// Detailed vulnerability finding
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityFinding {
    /// Unique identifier for the finding
    pub id: Uuid,
    /// File path where the vulnerability was found
    pub file_path: String,
    /// Line number (0-based)
    pub line_number: usize,
    /// Column number (0-based)
    pub column_number: usize,
    /// Vulnerability severity
    pub severity: VulnerabilitySeverity,
    /// Vulnerability category
    pub category: VulnerabilityCategory,
    /// Title of the vulnerability
    pub title: String,
    /// Detailed description
    pub description: String,
    /// Code snippet showing the vulnerability
    pub code_snippet: String,
    /// Suggested fix
    pub suggested_fix: String,
    /// Confidence score (0.0 to 1.0)
    pub confidence: f64,
    /// Detection method used
    pub detection_method: DetectionMethod,
    /// Related CWE (Common Weakness Enumeration) ID
    pub cwe_id: Option<String>,
    /// Additional metadata
    pub metadata: HashMap<String, String>,
}

/// Detection method used to find the vulnerability
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum DetectionMethod {
    /// Pattern-based detection
    PatternBased,
    /// Semantic analysis with GNN
    SemanticAnalysis,
    /// Machine learning detection
    MachineLearning,
    /// Hybrid approach (multiple methods)
    Hybrid,
}

/// Scan result containing all findings
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScanResult {
    /// Unique identifier for the scan
    pub scan_id: Uuid,
    /// File that was scanned
    pub file_path: String,
    /// All vulnerability findings
    pub findings: Vec<VulnerabilityFinding>,
    /// Scan statistics
    pub statistics: ScanStatistics,
    /// Timestamp when scan started
    pub scan_started: chrono::DateTime<chrono::Utc>,
    /// Timestamp when scan completed
    pub scan_completed: chrono::DateTime<chrono::Utc>,
    /// Total scan duration in milliseconds
    pub scan_duration_ms: u64,
}

/// Scan statistics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScanStatistics {
    /// Total lines of code scanned
    pub total_lines: usize,
    /// Number of findings by severity
    pub findings_by_severity: HashMap<VulnerabilitySeverity, usize>,
    /// Number of findings by category
    pub findings_by_category: HashMap<VulnerabilityCategory, usize>,
    /// Number of findings by detection method
    pub findings_by_method: HashMap<DetectionMethod, usize>,
    /// Average confidence score
    pub average_confidence: f64,
}

/// Main AEGIS-BUGS vulnerability scanner
pub struct VulnerabilityScanner {
    /// Scanner configuration
    config: VulnerabilityScannerConfig,
    /// Semantic analyzer using graph neural networks
    semantic_analyzer: SemanticAnalyzer,
    /// Pattern detector for known vulnerability signatures
    pattern_detector: PatternDetector,
    /// Machine learning detector
    ml_detector: MLDetector,
    /// LTMC manager for pattern storage and learning
    ltmc_manager: std::sync::Arc<LTMManager>,
}

impl VulnerabilityScanner {
    /// Create a new vulnerability scanner
    pub fn new(
        config: VulnerabilityScannerConfig,
        ltmc_manager: std::sync::Arc<LTMManager>,
    ) -> Result<Self> {
        let semantic_analyzer = SemanticAnalyzer::new(&config)?;
        let pattern_detector = PatternDetector::new(&config)?;
        let ml_detector = MLDetector::new(&config)?;

        Ok(Self {
            config,
            semantic_analyzer,
            pattern_detector,
            ml_detector,
            ltmc_manager,
        })
    }

    /// Scan a single file for vulnerabilities
    pub async fn scan_file(&self, file: &CodeFile) -> Result<ScanResult> {
        let scan_id = Uuid::new_v4();
        let scan_started = chrono::Utc::now();

        tracing::info!("Starting vulnerability scan for file: {}", file.path);

        // Run async detection methods in parallel
        let (pattern_findings, ml_findings) = tokio::join!(
            self.pattern_detector.detect_vulnerabilities(file),
            self.ml_detector.detect_vulnerabilities(file)
        );

        // Run sync semantic analysis
        let semantic_findings =
            self.semantic_analyzer
                .analyze(&file.content, &file.path, &file.language);

        let mut all_findings = Vec::new();

        // Collect findings from all methods
        if let Ok(findings) = pattern_findings {
            all_findings.extend(findings);
        }

        if let Ok(findings) = semantic_findings {
            all_findings.extend(findings.vulnerabilities.into_iter().map(|v| v.into()));
        }

        if let Ok(findings) = ml_findings {
            all_findings.extend(findings);
        }

        // Remove duplicates and merge overlapping findings
        let merged_findings = self.merge_findings(all_findings);

        // Generate scan statistics
        let statistics = self.generate_statistics(&merged_findings, file.content.lines().count());

        let scan_completed = chrono::Utc::now();
        let scan_duration_ms = (scan_completed - scan_started).num_milliseconds() as u64;

        let scan_result = ScanResult {
            scan_id,
            file_path: file.path.clone(),
            findings: merged_findings,
            statistics,
            scan_started,
            scan_completed,
            scan_duration_ms,
        };

        // Store scan results in LTMC for learning
        self.store_scan_results(&scan_result).await?;

        tracing::info!(
            "Vulnerability scan completed for file: {} in {}ms, found {} vulnerabilities",
            file.path,
            scan_duration_ms,
            scan_result.findings.len()
        );

        Ok(scan_result)
    }

    /// Merge and deduplicate findings from different detection methods
    fn merge_findings(&self, findings: Vec<VulnerabilityFinding>) -> Vec<VulnerabilityFinding> {
        let mut merged = Vec::new();
        let mut seen_positions = std::collections::HashSet::new();

        for finding in findings {
            let position_key = (
                finding.file_path.clone(),
                finding.line_number,
                finding.column_number,
            );

            if !seen_positions.contains(&position_key) {
                seen_positions.insert(position_key);
                merged.push(finding);
            } else {
                // Merge with existing finding if it exists
                if let Some(existing) = merged.iter_mut().find(|f| {
                    f.file_path == finding.file_path && f.line_number == finding.line_number
                }) {
                    // Update confidence to maximum
                    existing.confidence = existing.confidence.max(finding.confidence);
                    // Mark as hybrid detection if multiple methods agree
                    if existing.detection_method != finding.detection_method {
                        existing.detection_method = DetectionMethod::Hybrid;
                    }
                }
            }
        }

        // Sort by severity and confidence
        merged.sort_by(|a, b| {
            let severity_order = |s: &VulnerabilitySeverity| match s {
                VulnerabilitySeverity::Critical => 0,
                VulnerabilitySeverity::High => 1,
                VulnerabilitySeverity::Medium => 2,
                VulnerabilitySeverity::Low => 3,
                VulnerabilitySeverity::Informational => 4,
            };

            severity_order(&a.severity)
                .cmp(&severity_order(&b.severity))
                .then(
                    b.confidence
                        .partial_cmp(&a.confidence)
                        .unwrap_or(std::cmp::Ordering::Equal),
                )
        });

        merged
    }

    /// Generate scan statistics
    fn generate_statistics(
        &self,
        findings: &[VulnerabilityFinding],
        total_lines: usize,
    ) -> ScanStatistics {
        let mut findings_by_severity = HashMap::new();
        let mut findings_by_category = HashMap::new();
        let mut findings_by_method = HashMap::new();
        let mut total_confidence = 0.0;

        for finding in findings {
            *findings_by_severity
                .entry(finding.severity.clone())
                .or_insert(0) += 1;
            *findings_by_category
                .entry(finding.category.clone())
                .or_insert(0) += 1;
            *findings_by_method
                .entry(finding.detection_method.clone())
                .or_insert(0) += 1;
            total_confidence += finding.confidence;
        }

        let average_confidence = if findings.is_empty() {
            0.0
        } else {
            total_confidence / findings.len() as f64
        };

        ScanStatistics {
            total_lines,
            findings_by_severity,
            findings_by_category,
            findings_by_method,
            average_confidence,
        }
    }

    /// Store scan results in LTMC for learning
    async fn store_scan_results(&self, scan_result: &ScanResult) -> Result<()> {
        use odincode_ltmc::{LearningPattern, PatternType};

        let mut context = HashMap::new();
        context.insert("file_path".to_string(), scan_result.file_path.clone());
        context.insert(
            "total_findings".to_string(),
            scan_result.findings.len().to_string(),
        );
        context.insert(
            "scan_duration_ms".to_string(),
            scan_result.scan_duration_ms.to_string(),
        );
        context.insert(
            "average_confidence".to_string(),
            scan_result.statistics.average_confidence.to_string(),
        );

        // Store summary pattern
        let pattern = LearningPattern {
            id: Uuid::new_v4(),
            pattern_type: PatternType::CodePattern,
            content: format!(
                "Vulnerability scan completed for file: {}, found {} vulnerabilities",
                scan_result.file_path,
                scan_result.findings.len()
            ),
            context,
            created: chrono::Utc::now(),
            last_accessed: chrono::Utc::now(),
            access_count: 0,
            confidence: scan_result.statistics.average_confidence as f32,
        };

        self.ltmc_manager.store_pattern(pattern).await?;

        // Store individual findings as learning patterns
        for finding in &scan_result.findings {
            let mut finding_context = HashMap::new();
            finding_context.insert("file_path".to_string(), finding.file_path.clone());
            finding_context.insert("line_number".to_string(), finding.line_number.to_string());
            finding_context.insert("severity".to_string(), format!("{:?}", finding.severity));
            finding_context.insert("category".to_string(), format!("{:?}", finding.category));
            finding_context.insert("confidence".to_string(), finding.confidence.to_string());
            finding_context.insert(
                "detection_method".to_string(),
                format!("{:?}", finding.detection_method),
            );

            let finding_pattern = LearningPattern {
                id: Uuid::new_v4(),
                pattern_type: PatternType::ErrorSolution,
                content: format!(
                    "Vulnerability found: {} at {}:{} - {}",
                    finding.title, finding.file_path, finding.line_number, finding.description
                ),
                context: finding_context,
                created: chrono::Utc::now(),
                last_accessed: chrono::Utc::now(),
                access_count: 0,
                confidence: finding.confidence as f32,
            };

            self.ltmc_manager.store_pattern(finding_pattern).await?;
        }

        Ok(())
    }

    /// Convert vulnerability findings to code issues for the core system
    pub fn findings_to_issues(&self, findings: Vec<VulnerabilityFinding>) -> Vec<CodeIssue> {
        findings
            .into_iter()
            .map(|finding| {
                let issue_type = match finding.category {
                    VulnerabilityCategory::Security => IssueType::Security,
                    VulnerabilityCategory::Performance => IssueType::Performance,
                    VulnerabilityCategory::MemorySafety => IssueType::PotentialBug,
                    VulnerabilityCategory::Concurrency => IssueType::PotentialBug,
                    VulnerabilityCategory::InputValidation => IssueType::Security,
                    VulnerabilityCategory::Auth => IssueType::Security,
                    VulnerabilityCategory::DataHandling => IssueType::Security,
                    VulnerabilityCategory::CodeQuality => IssueType::Style,
                };

                CodeIssue {
                    id: finding.id,
                    issue_type,
                    severity: match finding.severity {
                        VulnerabilitySeverity::Critical => Severity::Critical,
                        VulnerabilitySeverity::High => Severity::High,
                        VulnerabilitySeverity::Medium => Severity::Medium,
                        VulnerabilitySeverity::Low => Severity::Low,
                        VulnerabilitySeverity::Informational => Severity::Low, // Map to Low since no Info variant
                    },
                    description: format!("{}: {}", finding.title, finding.description),
                    line_number: finding.line_number,
                    column_number: finding.column_number,
                    suggestion: Some(finding.suggested_fix),
                }
            })
            .collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vulnerability_severity_ordering() {
        let severities = vec![
            VulnerabilitySeverity::Critical,
            VulnerabilitySeverity::High,
            VulnerabilitySeverity::Medium,
            VulnerabilitySeverity::Low,
            VulnerabilitySeverity::Informational,
        ];

        for i in 1..severities.len() {
            assert!(severities[i - 1] <= severities[i]);
        }
    }

    #[test]
    fn test_merge_findings_deduplication() {
        let scanner = VulnerabilityScanner::new(
            VulnerabilityScannerConfig::default(),
            std::sync::Arc::new(LTMManager::new()),
        )
        .unwrap();

        let finding1 = VulnerabilityFinding {
            id: Uuid::new_v4(),
            file_path: "test.rs".to_string(),
            line_number: 10,
            column_number: 5,
            severity: VulnerabilitySeverity::High,
            category: VulnerabilityCategory::Security,
            title: "Test vulnerability".to_string(),
            description: "Test description".to_string(),
            code_snippet: "let x = 5;".to_string(),
            suggested_fix: "Fix the issue".to_string(),
            confidence: 0.8,
            detection_method: DetectionMethod::PatternBased,
            cwe_id: None,
            metadata: HashMap::new(),
        };

        let finding2 = VulnerabilityFinding {
            id: Uuid::new_v4(),
            file_path: "test.rs".to_string(),
            line_number: 10,
            column_number: 5,
            severity: VulnerabilitySeverity::Medium,
            category: VulnerabilityCategory::Security,
            title: "Test vulnerability duplicate".to_string(),
            description: "Test description duplicate".to_string(),
            code_snippet: "let x = 5;".to_string(),
            suggested_fix: "Fix the issue duplicate".to_string(),
            confidence: 0.9,
            detection_method: DetectionMethod::SemanticAnalysis,
            cwe_id: None,
            metadata: HashMap::new(),
        };

        let merged = scanner.merge_findings(vec![finding1, finding2]);
        assert_eq!(merged.len(), 1);
        assert_eq!(merged[0].confidence, 0.9);
        assert_eq!(merged[0].detection_method, DetectionMethod::Hybrid);
    }
}
