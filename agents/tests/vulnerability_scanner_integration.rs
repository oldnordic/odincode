//! Integration tests for AEGIS-BUGS vulnerability scanner integration

use anyhow::Result;
use odincode_agents::{
    vulnerability_scanner::{
        config::VulnerabilityScannerConfig, VulnerabilityCategory, VulnerabilityScanner,
    },
    AgentCoordinator, AgentType, LTMCIntegration,
};
use odincode_core::llm_integration::LLMIntegrationManager;
use odincode_core::{CodeEngine, CodeFile, Severity};
use odincode_ltmc::LTMManager;
use std::sync::Arc;
use tempfile::NamedTempFile;

#[tokio::test]
async fn test_vulnerability_scanner_integration() -> Result<()> {
    // Initialize core components
    let core_engine = Arc::new(CodeEngine::new());
    let ltmc_manager = Arc::new(LTMManager::new());
    let llm_manager = Arc::new(LLMIntegrationManager::new()?);
    let ltmc_integration = Arc::new(LTMCIntegration::new(
        ltmc_manager.clone(),
        core_engine.clone(),
        llm_manager,
    ));

    // Create agent coordinator
    let coordinator =
        AgentCoordinator::new(core_engine.clone(), ltmc_manager.clone(), ltmc_integration);

    // Register a bug detection agent
    let agent_id = coordinator
        .register_agent(
            AgentType::BugDetector,
            "AEGIS-BUGS Scanner".to_string(),
            "Advanced vulnerability scanner using GNNs and ML".to_string(),
            vec![
                "security".to_string(),
                "vulnerability".to_string(),
                "bug_detection".to_string(),
            ],
            0.8,
        )
        .await?;

    // Create test files with known vulnerabilities that match AEGIS-BUGS patterns
    let vulnerable_code = r#"
use std::fs::File;
use std::io::Read;

fn read_user_file(path: &str) -> Result<String, std::io::Error> {
    let mut file = File::open(path)?; // Path traversal vulnerability
    let mut contents = String::new();
    file.read_to_string(&mut contents)?;
    Ok(contents)
}

// This should be detected by AEGIS-BUGS - unsafe block
unsafe fn dangerous_function() {
    let raw_ptr = 5 as *const i32;
    println!("Dangerous: {}", *raw_ptr); // Raw pointer dereference
}

// This should be detected by AEGIS-BUGS - static mut
static mut GLOBAL_COUNTER: u32 = 0;

fn increment_counter() {
    unsafe {
        GLOBAL_COUNTER += 1; // Unsafe access to static mut
    }
}

// This should be detected by AEGIS-BUGS - another unsafe block
fn process_data(data: *const u8) -> u8 {
    unsafe {
        *data // Raw pointer dereference
    }
}
"#;

    // Create temporary file and keep it alive
    let mut temp_file = NamedTempFile::new()?;
    use std::io::Write;
    temp_file.write_all(vulnerable_code.as_bytes())?;
    let temp_path = temp_file.path().to_string_lossy().to_string();

    // Keep the file alive by not dropping it
    let _temp_file = temp_file;

    // Register the file with the core engine
    let file_id = core_engine
        .load_file(
            temp_path.clone(),
            vulnerable_code.to_string(),
            "rust".to_string(),
        )
        .await?;

    // Execute the bug detection agent
    let suggestions = coordinator.execute_agent_on_file(agent_id, file_id).await?;

    // Debug output
    println!("Suggestions result: {:?}", suggestions);

    // Verify that vulnerabilities were detected
    assert!(
        suggestions.is_some(),
        "Should detect vulnerabilities in the test code"
    );
    let suggestions = suggestions.unwrap();
    assert!(
        !suggestions.is_empty(),
        "Should detect vulnerabilities in the test code"
    );

    // Check that we have different types of vulnerability suggestions
    let mut security_suggestions = 0;
    let mut refactor_suggestions = 0;

    for suggestion in &suggestions {
        match suggestion.suggestion_type {
            odincode_core::SuggestionType::Refactor => refactor_suggestions += 1,
            _ => {}
        }

        // Verify suggestions have proper confidence scores
        assert!(suggestion.confidence > 0.0, "Confidence should be > 0");
        assert!(suggestion.confidence <= 1.0, "Confidence should be <= 1");

        // Verify descriptions are meaningful
        assert!(
            !suggestion.description.is_empty(),
            "Description should not be empty"
        );
    }

    // Should detect code quality issues
    assert!(
        refactor_suggestions > 0,
        "Should detect code quality issues"
    );

    println!("Detected {} vulnerabilities:", suggestions.len());
    for (i, suggestion) in suggestions.iter().enumerate() {
        println!(
            "  {}: {} (confidence: {:.2})",
            i + 1,
            suggestion.description,
            suggestion.confidence
        );
    }

    Ok(())
}

#[tokio::test]
async fn test_vulnerability_scanner_performance() -> Result<()> {
    // Initialize LTMC manager for this test
    let ltmc_manager = Arc::new(LTMManager::new());

    // Test that the scanner meets the <100ms response time requirement
    let mut config = VulnerabilityScannerConfig::default();
    config.enable_ml_detection = true;
    config.enable_semantic_analysis = true;
    config.enable_pattern_detection = true;

    let scanner = VulnerabilityScanner::new(config, ltmc_manager.clone())?;

    // Create a moderately sized test file
    let test_code = r#"
fn safe_function(input: &str) -> String {
    input.to_uppercase()
}

fn another_function(x: i32) -> i32 {
    x * 2
}

fn process_data(data: &[u8]) -> Vec<u8> {
    data.iter().map(|&b| b.wrapping_add(1)).collect()
}
"#
    .repeat(50); // Make it larger

    let mut temp_file = NamedTempFile::new()?;
    use std::io::Write;
    temp_file.write_all(test_code.as_bytes())?;
    let temp_path = temp_file.path().to_string_lossy().to_string();

    let code_file = CodeFile {
        id: uuid::Uuid::new_v4(),
        path: temp_path.clone(),
        language: "rust".to_string(),
        content: test_code,
        modified: chrono::Utc::now(),
    };

    // Measure scan time
    let start_time = std::time::Instant::now();
    let result = scanner.scan_file(&code_file).await?;
    let duration = start_time.elapsed();

    // Verify performance requirement
    assert!(
        duration.as_millis() < 100,
        "Vulnerability scan should complete in <100ms, took {:?}",
        duration
    );

    println!(
        "Scan completed in {:?} with {} vulnerabilities detected",
        duration,
        result.findings.len()
    );

    Ok(())
}

#[tokio::test]
async fn test_vulnerability_scanner_configuration() -> Result<()> {
    // Initialize LTMC manager for this test
    let ltmc_manager = Arc::new(LTMManager::new());

    // Test different scanner configurations
    let mut config_fast = VulnerabilityScannerConfig::default();
    config_fast.enable_ml_detection = false;
    config_fast.enable_semantic_analysis = false;
    config_fast.enable_pattern_detection = true;

    let mut config_comprehensive = VulnerabilityScannerConfig::default();
    config_comprehensive.enable_ml_detection = true;
    config_comprehensive.enable_semantic_analysis = true;
    config_comprehensive.enable_pattern_detection = true;

    let test_code = r#"
fn vulnerable_function(input: &str) {
    let _ = input.len(); // Simple code for testing
}
"#;

    let mut temp_file = NamedTempFile::new()?;
    use std::io::Write;
    temp_file.write_all(test_code.as_bytes())?;
    let temp_path = temp_file.path().to_string_lossy().to_string();

    let code_file = CodeFile {
        id: uuid::Uuid::new_v4(),
        path: temp_path.clone(),
        language: "rust".to_string(),
        content: test_code.to_string(),
        modified: chrono::Utc::now(),
    };

    // Test fast configuration
    let scanner_fast = VulnerabilityScanner::new(config_fast, ltmc_manager.clone())?;
    let start_time = std::time::Instant::now();
    let result_fast = scanner_fast.scan_file(&code_file).await?;
    let duration_fast = start_time.elapsed();

    // Test comprehensive configuration
    let scanner_comprehensive =
        VulnerabilityScanner::new(config_comprehensive, ltmc_manager.clone())?;
    let start_time = std::time::Instant::now();
    let result_comprehensive = scanner_comprehensive.scan_file(&code_file).await?;
    let duration_comprehensive = start_time.elapsed();

    // Fast configuration should be quicker
    assert!(
        duration_fast <= duration_comprehensive,
        "Fast configuration should be quicker or equal to comprehensive"
    );

    // Both should produce valid results
    assert!(
        result_fast.statistics.average_confidence >= 0.0
            && result_fast.statistics.average_confidence <= 1.0
    );
    assert!(
        result_comprehensive.statistics.average_confidence >= 0.0
            && result_comprehensive.statistics.average_confidence <= 1.0
    );

    println!(
        "Fast scan: {:?} (confidence: {:.2})",
        duration_fast, result_fast.statistics.average_confidence
    );
    println!(
        "Comprehensive scan: {:?} (confidence: {:.2})",
        duration_comprehensive, result_comprehensive.statistics.average_confidence
    );

    Ok(())
}
